## [416. Partition Equal Subset Sum](https://leetcode-cn.com/problems/Partition-Equal-Subset-Sum)
### 日期:
>2020-05-23 22:32:49 电脑不知道能卖多少钱，今天学了word embedding一开始一头雾水，后来似乎有些理解，继续加油！
### 题目:
![text](https://github.com/zjuzhfbloodz/LeetCode/blob/master/questions/0416.png?raw=true)
### 思路:
>DP动态规划，思考好状态转移方程即可，今天进入0-1背包问题，这个题目没太懂，看了解答懂了一些，加油！
### 代码:

> DP，见[解答](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/dong-tai-gui-hua-kong-jian-you-hua-zhu-xing-jie--2/)
```python
class Solution(object):
    def canPartition(self, nums):
        all_sum, N = sum(nums), len(nums)
        if all_sum % 2 == 1:
            return False
        half_sum = all_sum // 2
        # flag[i][j]: 表示nums数组前i个元素是否可以表示和为j的状态True or False
        flag = [[False]*(half_sum+1) for _ in range(N)]
        # 只要nums中的元素可以组合成和为half_sum即可。同时也规定了元素不可以扩充使用，
        # 这一点和0-1背包问题不同，所以第一层遍历就是遍历nums数组，避免重复
        for i in range(N):
            for j in range(nums[i], half_sum+1):
                # 此状态说明当前元素恰好为j，直接返回True
                if j == nums[i]:
                    flag[i][j] = True
                else:
                    flag[i][j] = flag[i-1][j] or flag[i-1][j-nums[i]]
        return flag[-1][-1]
```
> 由于每一步的更新只和i-1有关，故可以空间优化到一维，记得用逆序
```python
class Solution(object):
    def canPartition(self, nums):
        sums=sum(nums)
        if sums%2==1:
            return False
        target=sums//2
        dp=[False for _ in range(target+1)]
        dp[0]=True
        for i in range(len(nums)):
            for j in range(target,nums[i]-1,-1):
                dp[j]=dp[j] or dp[j-nums[i]]
        return dp[-1]
```
### 思考:
>明天记得数据结构考试！！！有空就做了吧

>2020/10/09 复习，自己做出来了，但是是最基本的想法没有优化，很慢，记得可以空间优化！加油！
