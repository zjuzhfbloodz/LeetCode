[TOC]

# 动态规划 DP

#### [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

动态规划的思路，可以按层优化空间到O(N)，注意下标和边界条件

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        if not triangle: return 0
        dp = triangle[0]
        n = len(triangle)
        for i in range(1,n):
            new_dp = [dp[0]+triangle[i][0]]
            for j in range(1,i):
                new_dp.append(triangle[i][j]+min(dp[j],dp[j-1]))
            new_dp.append(triangle[i][i]+dp[i-1])
            dp = new_dp
        return min(dp)
```

## 斐波那契数列

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

DP表示前i间房可以偷盗的最多金额，投了i就只能DP[i-2]，不偷i才可以DP[i-1]；且可转化为1D，因为只用到两个数

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums: return 0
        n = len(nums)
        pre,cur = 0,nums[0]
        output = nums[0]
        for i in range(1,n):
            pre,cur = cur,max(pre+nums[i],cur) #递推公式
            output = max(output,cur)
        return output
```

#### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

类似上题，只需要排除第一家和最后一家分别rob即可

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0: return 0
        if n == 1: return nums[0]
        return max(self.inner(nums[:-1]),self.inner(nums[1:]))

    def inner(self, nums: List[int]) -> int:
        if not nums: return 0
        n = len(nums)
        pre,cur = 0,nums[0]
        for i in range(1,n):
            pre,cur = cur,max(pre+nums[i],cur) #递推公式
        return cur
```

## 矩阵路径

#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

DP正常二维矩阵可以做，也可以优化为1D

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [1]*n
        for i in range(1,m):
            for j in range(1,n):
                dp[j] = dp[j-1]+dp[j]
        return dp[-1]
```

#### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

和上题类似，遇到石块儿的地方直接置0即可

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if not obstacleGrid or not obstacleGrid[0]: return 0
        m,n = len(obstacleGrid),len(obstacleGrid[0])
        dp = [1]*n
        dp[0] = 1-obstacleGrid[0][0]
        for i in range(1,n):
            dp[i] = min(dp[i-1],1-obstacleGrid[0][i])
        for i in range(1,m):
            for j in range(n):
                if obstacleGrid[i][j] == 1: dp[j] = 0
                elif j > 0: dp[j] = dp[j-1]+dp[j]
        return dp[-1]
```

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

正常做只需要把第一行第一列先确定后续递推即可，可以优化空间到O(N)，一行一行的更新，每个数据只需要左边的这轮结果和上面的上轮结果，故只需要一行数组来保存

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        if not grid: return 0
        m,n = len(grid),len(grid[0])
        dp = [[0]*n for i in range(m)]
        dp[0][0] = grid[0][0]
        for i in range(1,n):
            dp[0][i] = dp[0][i-1] + grid[0][i]
        for j in range(1,m):
            dp[j][0] = dp[j-1][0] + grid[j][0]
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j] = grid[i][j] + min(dp[i-1][j],dp[i][j-1])
        return dp[-1][-1]
# 空间优化后的代码，dp[0]的目的是直接把第一列的元素放到dp[1]
class Solution:
    def minPathSum(self, grid):
        dp = [float('inf')] * (len(grid[0])+1)
        dp[1] = 0
        for row in grid:
            for idx, num in enumerate(row):
                dp[idx + 1] = min(dp[idx], dp[idx + 1]) + num
        return dp[-1]
```

## 数组区间

#### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

保存前缀和，之后sum[j] - sum[i]就是中间的和

```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.qsum = [0]
        for i in range(len(nums)):
            self.qsum.append(self.qsum[-1]+nums[i])


    def sumRange(self, left: int, right: int) -> int:
        return self.qsum[right+1] - self.qsum[left]

# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(left,right)
```

#### [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

要想到用数据的差diff这个数组去做，DP代表的意义是序列前i个中的等差数列个数

```python
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 3: return 0
        diff = [0] * (n-1)
        diff[0] = nums[1] - nums[0]
        dp = [0] * n
        for i in range(2,n):
            diff[i-1] = nums[i] - nums[i-1]
            if diff[i-1] == diff[i-2]:
                dp[i] = dp[i-1] + 1
        return sum(dp)
```

