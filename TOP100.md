[TOC]

### 一些思想

1. 动态规划问题搞清楚或记牢DP代表的含义，之后对应的转移方程其实迎刃而解了
2. 背包问题通解：

- 完全背包问题，按先硬币后数值的双循环**正序**更新1D的dp

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        for c in candidates: #先硬币
            for i in range(c,target+1): #后数值
                dp[i] += dp[i-c]
        return dp[-1]
```

- 01背包问题，按先硬币后数值的双循环**逆序**更新1D的dp
```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        for c in candidates: #先硬币
            for i in range(target,c-1,-1): #后逆序数值
                dp[i] += dp[i-c]
        return dp[-1]
```
#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

> **Q:** HashMap

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201022220130608.png" alt="image-20201022220130608" style="zoom:50%;" />

> **A:** 可以用字典加速达到O(N)，继续优化就是一边更新字典一边选，选到了直接output
```python
class Solution:
    def twoSum(self, nums, target):
        #用字典来加速查询
        dik = {}
        for i in range(len(nums)):
            if dik.get(target - nums[i]) is not None: #找到了就输出
                return([dik[target - nums[i]],i])
            dik[nums[i]] = i #加入新元素
```


#### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

> **Q:** Linked List

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201022222353644.png" alt="image-20201022222353644" style="zoom:50%;" />

> **A:**
```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy,head,r = ListNode(),ListNode(),0
        dummy.next = head
        while l1 or l2 or r: #r是余数，只要还有l1l2或r就要继续增加节点
            n1 = l1.val if l1 else 0
            n2 = l2.val if l2 else 0
            num,r = (n1 + n2 + r) % 10,(n1 + n2 + r) // 10
            head.next = ListNode(num)
            head = head.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None

        return dummy.next.next
```


#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

> **Q:** Dual Pointer

![text](https://github.com/zjuzhfbloodz/LeetCode/raw/master/questions/0003.png?raw=true)

> **A:**
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        #思路是双指针，或者叫滑动窗口
        i,j,maxlen = 0,0,0

        while j < len(s): #后面的指针不能超过s长度
            if s[j] not in s[i:j]: #没重复，j向后
                j += 1
            else:
                maxlen = max(maxlen,j-i)   #重复了，更新最值，i向后，直到没有重复之前j不变
                i += 1     
                #i += s[i:j].find(s[j]) + 1  #没有提升多少，迅速更新最新i到和j重复的字符之后
                 
        return max(maxlen,j-i) #防止全不同的序列没有更新过
```

#### [4*^. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

> **Q:** Recursion

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201023183841426.png" alt="image-20201023183841426" style="zoom:50%;" />

> **A:** 本质上是两个有序数组中找第k小的数
```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        #技巧使代码更统一精简，如果两个数组长度和是奇数，那么k1=k2，计算均值同偶数形式不用改写了
        n1,n2 = len(nums1),len(nums2)
        k1 = (n1+n2+1) // 2
        k2 = (n1+n2+2) // 2
        #本质上是两个有序数组中找第k小的数
        def inner(l1,l2,k):
            
            if len(l1) < len(l2): l1,l2 = l2,l1#保持nums1比较长
            if len(l2) == 0: return l1[k-1] #即当nums2走到尽头的时候，直接返回
            if k == 1: return min(l1[0],l2[0]) #找最小数，比较数组首位
            t = min(k//2,len(l2)) # t每次是要找的位数的1/2，这样使复杂度达到log，且保证不上溢
            if l1[t-1] >= l2[t-1]: return inner(l1,l2[t:],k-t) #这里是t意味前k//2个都不能要
            else: return inner(l1[t:],l2,k-t)

        return (inner(nums1,nums2,k1)+inner(nums1,nums2,k2)) / 2

```

#### [[动态规划]-5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

> **Q:** Dynamic Programming

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201024173612969.png" alt="image-20201024173612969" style="zoom:50%;" />

> **A:** 按回文串的长度x进行逐步DP动态规划，长度为3的依靠长度为1的，长度为5的依靠长度为3的，依次类推；类似题目647
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        #DP[i][j]表示从s[j]开始的长度为i的字符串是否为回文
        if not s: return ''
        n = len(s)
        dp = [[False]*n for i in range(n+1)]
        dp[0] = [True]*n
        dp[1] = [True]*n
        output = s[0]
        for i in range(2,n+1):
            for j in range(n-i+1):
                if s[j] == s[j+i-1] and dp[i-2][j+1]:
                    dp[i][j] = True
                    output = s[j:j+i]
        return output
```

#### [[动态规划]-10*. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

> **Q:** Dynamic Programming

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201025214110071.png" alt="image-20201025214110071" style="zoom:50%;" />

> **A:** DP动态规划，分p中的字符种类三种情况"x * ."思考转移方程，[解答](https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/)
```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        #match函数用来判断两个字符是否匹配
        def match(i,j):
            if i == 0: return False #当s为空时，显然p[j-1]不能匹配，不用考虑诸如a*的情况，都在dp中包含了
            if p[j-1] == '.': return True
            return s[i-1] == p[j-1]
        #DP[i][j]表示s的前i个字符和p的前j个字符是否匹配
        m,n = len(s),len(p)
        dp = [[False]*(n+1) for i in range(m+1)]
        dp[0][0] = True
        for i in range(m+1):
            for j in range(1,n+1):
                if p[j-1] == '*': #如果为*有两种情况，抛去前两个和i匹配，或者如果相等就和i-1继续匹配
                    dp[i][j] = dp[i][j-2]
                    if match(i,j-1):
                        dp[i][j] = dp[i][j-2] or dp[i-1][j]
                else: #否则只能看是否相等
                    if match(i,j):
                        dp[i][j] = dp[i-1][j-1]
        return dp[-1][-1]

```

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

> **Q:** Dual Pointer

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201026150625433.png" alt="image-20201026150625433" style="zoom:50%;" />

> **A:** 头尾双指针，每次的area结果都是当前所有边中和短边构成面积的max，之后即可舍弃该短边，即短边索引+1或-1
```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # 对于每一个坐标i，他所能构成的area的max高度是自己的高度
        # area = (j-i) * min(height[j],height[i])，依然是双指针
        i,j,maxarea = 0,len(height)-1,0
        while i != j:
            if height[i] <= height[j]:
                area = height[i] * (j-i)
                i += 1
            else:
                area = height[j] * (j-i)
                j -= 1
            maxarea = max(maxarea,area)
                
        return maxarea
```

#### [15*. 三数之和](https://leetcode-cn.com/problems/3sum/)

> **Q:** HashMap or Sort

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201027215546487.png" alt="image-20201027215546487" style="zoom:50%;" />

> **A:** 可以用hashmap类似第1题中的操作将复杂度降到O(N2)但判断更难，也可以使用排序的方法，更巧妙一些，**重点在于不要重复**
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        #排序+双指针
        output,n = [],len(nums)
        nums = sorted(nums)
        for i in range(n): #遍历每个点i，从i+1到n-1，找和可以为0且不重复的（因为有序）
            if nums[i] > 0: break #如果当前都大于0了，之后的不可能和为0
            if i > 0 and nums[i] == nums[i-1]: continue #重复的也要跳过
            l,r = i+1,n-1 #满足条件的开始循环找，和大于0，右端往左，否则左端往右，=0要注意不能和上一次的重复并移动双指针
            while l < r:
                sum3 = nums[i] + nums[l] + nums[r]
                if sum3 < 0: l += 1 
                elif sum3 > 0: r -= 1
                else:
                    if r == n-1 or (nums[l-1] != nums[l] or nums[r+1] != nums[r]):
                        output.append([nums[i],nums[l],nums[r]])
                    l,r = l+1,r-1
                    
        return output
```

#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

> **Q:** HashMap

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201028205544281.png" alt="image-20201028205544281" style="zoom:50%;" />

> **A:** 利用hashmap+回溯backtrack
```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: return []
        phoneMap = {'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}
        
        def tb(index):
            if index == n:
                output.append(''.join(s[:]))
                return 
            for i in phoneMap[digits[index]]:
                s.append(i)
                tb(index+1)
                s.pop()
        output = []
        s = []
        n = len(digits)
        tb(0)
        return output
```

#### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

> **Q:** Linked List

![image-20201029203546392](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201029203546392.png)

> **A:** 不用空节点的话，如果只有一个head且n=1没法执行，最后记得return dummy.next（也是为了特殊情况）
```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        #双指针，加一个空头不用判断特殊情况（即删除头节点的情况）
        dummy = ListNode(next=head)
        l = r = dummy
        for i in range(n+1): r = r.next
        while r:
            l,r = l.next,r.next
        l.next = l.next.next
        return dummy.next
```

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

> **Q:** Stack

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201109194515530.png" alt="image-20201109194515530" style="zoom:50%;" />

> **A:** 难度不大，使用stack先进后出即可
```python
class Solution:
    def isValid(self, s: str) -> bool:
        #先进后出stack，注意右括号是不能进入stack的，进入了就说明False
        stack,n = [],len(s)
        pairs = {'(':')','{':'}','[':']'}
        for i in range(n)
            if s[i] in pairs: stack.append(s[i])
            else:
                if stack and pairs[stack[-1]] == s[i]:
                    stack.pop()
                else:
                    return False
        #还剩元素说明肯定不匹配
        return True if stack else False
```

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

> **Q:** Linked List and Dual Pointer

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201109195701797.png" alt="image-20201109195701797" style="zoom:50%;" />

> **A:** 依次比较大小生成新链表即可
```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        #双指针
        dummy = ListNode()
        head = dummy
        while l1 and l2:
            if l1.val >= l2.val:
                head.next = l2
                l2 = l2.next
            else:
                head.next = l1
                l1 = l1.next
            head = head.next
        if l1: head.next = l1
        if l2: head.next = l2

        return dummy.next
```

#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

> **Q:** STACK or Dynamic Programming

![image-20201112200640224](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201112200640224.png)

> **A1:** 括号类问题都要遵守的规则：一个有效的组合的前任意个元素中，右括号不能多于左括号的个数
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        #n个'('和n个')'，且一个有效的组合的前任意个元素中，右括号不能多于左括号的个数
        output = ["("]
        counts = [(1,0)] #count用于记录目前output的所有元素中左右括号的个数，随output更新
        for i in range(2*n-1):
            length = len(output)
            for j in range(length):
                old,c = output.pop(0),counts.pop(0)
                if c[0] < n:#左括号不能超过n,此时可以添加左括号
                    output.append(old+'(')
                    counts.append((c[0]+1,c[1]))
                if c[1] < c[0]: #左括号比右括号多的时候可以添加右括号
                    output.append(old+')')
                    counts.append((c[0],c[1]+1))
        return output
```


#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

> **Q:** Heap or N Pointers

![image-20201204165107243](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201204165107243.png)

> **A:** 最小堆，复杂度nklog(k)，先将k个序列的第一个结点构成一个logk深度的最小堆，然后pop最小值，如果该节点还有next，将next入堆，继续做即可，每个节点入堆一次出堆一次（复杂度为log(k))，总计复杂度为nklog(k)
```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        import heapq
        dummy = ListNode(0)
        p = dummy
        head = []
        for i in range(len(lists)):
            if lists[i] :
                heapq.heappush(head, (lists[i].val, i))
                lists[i] = lists[i].next
        while head:
            val, idx = heapq.heappop(head)
            p.next = ListNode(val)
            p = p.next
            if lists[idx]:
                heapq.heappush(head, (lists[idx].val, idx))
                lists[idx] = lists[idx].next
        return dummy.next
```

#### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

> **Q:** 

![image-20201205145502711](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201205145502711.png)

> **A:** 找到从右到左的第一个逆序数列，这个数列无法通过交换两个数的位置得到下一个字典序，故需要更新序列前面的数字即可
```python
class Solution:
    def nextPermutation(self, nums) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k = n-1
        while k != 0 and nums[k] <= nums[k-1]: #找到从右到左的第一个逆序数列
            k -= 1
        nums[k:] = nums[k:][::-1] #将其逆转，并交换第一个大于前面数的序列中的数
        for i in range(k,n):
            if nums[i] > nums[k-1]:
                nums[i],nums[k-1] = nums[k-1],nums[i]
                break
```

#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

> **Q:**

![image-20201205173138334](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201205173138334.png)

> **A:** [这里](https://leetcode-cn.com/problems/longest-valid-parentheses/solution/)，维护一个栈，栈底元素是最后一个未匹配的右括号的位置，用来分割字符串同时记录合格的字符串长度
```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        #维护一个栈，栈底元素是最后一个未匹配的右括号的位置，用来分割字符串
        stack,maxlen,n = [-1],0,len(s)
        for i in range(n):
            if s[i] == '(':
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    maxlen = max(maxlen,i-stack[-1])
        return maxlen
#自己的想法，正反做两遍
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        l,r,n,maxl,maxr = 0,0,len(s),0,0
        for i in range(n-1,-1,-1):
            l = l+1 if s[i] == '(' else l
            r = r+1 if s[i] == ')' else r
            if r == l:
                maxl = max(maxl,2*l)
            elif l > r:
                l,r = 0,0
                
        l,r = 0,0
        for i in range(n):
            l = l+1 if s[i] == '(' else l
            r = r+1 if s[i] == ')' else r
            if r == l: 
                maxr = max(maxr,2*r)
            elif r > l:
                l,r = 0,0,
            
        return max(maxl,maxr)
```

#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

> **Q:** 二分搜索

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201207193822281.png" alt="image-20201207193822281" style="zoom:50%;" />

> **A:** 二分查找，但是l和r的状态更新有了变化，选择左区间(nums[l],target,nums[mid])有三种可能[4,5,7],[7,8,1],[7,1,2]，注意等号
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        #二分查找，状态更新有区别
        n = len(nums)
        l,r = 0,n-1
        while l <= r:
            mid = l + (r-l)//2 #二分
        #左区间(nums[l],target,nums[mid])有三种可能[4,5,7],[7,8,1],[7,1,2]
            if nums[mid] == target: return mid
            elif nums[l] <= target < nums[mid] or nums[mid] < nums[l] <= target or target < nums[mid] < nums[l]:
                r = mid - 1
            else:
                l = mid + 1
        return -1
```

#### [[完全背包]-39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215173114825.png" alt="image-20201215173114825" style="zoom:50%;" />

> **A:** 完全背包问题，第一种方法是朴素思想，第二种是优化到1D
```python
class Solution:
    def combinationSum(self, candidates, target: int):
        #完全背包问题
        n = len(candidates)
        dp = [[[] for i in range(n+1)] for j in range(target+1)]
        for i in range(1,n+1):
            for j in range(1,target+1):
                dp[j][i] += dp[j][i-1] #无论j和当前硬币的大小，都要将之前的加上
                if j == candidates[i-1]: dp[j][i] += [[candidates[i-1]]]
                if j > candidates[i-1]:
                    dp[j][i] += [x+[candidates[i-1]] for x in dp[j-candidates[i-1]][i]]
        return dp[-1][-1]
    
class Solution: #优化到1D
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        dp = [[] for i in range(target+1)]
        dp[0] = [[]]
        for c in candidates:
            for i in range(c,target+1):
                for combine in dp[i-c]:
                    dp[i].append(combine+[c])
        return dp[-1]
```

#### [[动态规划]-42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222120101668.png" alt="image-20201222120101668" style="zoom:50%;" />

> **A:** 要对每个height[i]找到0-(i-1)的max和(i+1)-(n-1)的max，这两个max中的min决定了height[i]所能接水的量，可以用DP来找；或者是用[巧方法](https://leetcode-cn.com/problems/trapping-rain-water/solution/wei-en-tu-jie-fa-zui-jian-dan-yi-dong-10xing-jie-j/)；DP可以优化到O1的空间复杂度，用双指针[见解答下面Lucien的评论](https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/)，即双指针指代左右两边的max，左边的max对于左边的index是可信的，右边同理，若左max小于右max，则左边index一定由左边决定，否则去看右边，类似84
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 用两个DP分别记录下标i左边和右边的max，i所能存储的水量就是min(左,右)-height[i]
        n = len(height)
        ldp = [0 for i in range(n)]
        rdp = [0 for i in range(n)]
        output = 0
        for i in range(1,n): ldp[i] = max(ldp[i-1],height[i-1])
        for i in range(n-2,0,-1): 
            rdp[i] = max(rdp[i+1],height[i+1])
            r = min(ldp[i],rdp[i]) - height[i]
            if r > 0:
                output += r
        return output

    
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        rain = 0
        l,r = 0,n-1
        leftmax,rightmax = 0,0 #leftmax对于左边是可信的，right同理
        while l <= r:
            if leftmax <= rightmax:
                leftmax = max(leftmax,height[l])
                rain += leftmax-height[l]
                l += 1
            else:
                rightmax = max(rightmax,height[r])
                rain += rightmax-height[r]
                r -= 1
        return rain
```

#### [[回溯]-46. 全排列](https://leetcode-cn.com/problems/permutations/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214140318038.png" alt="image-20201214140318038" style="zoom:50%;" />

> **A:** 前first-1个数字已经选好，后n-first如何选？就从后面依次和first位置交换（第一次自己和自己交换）即可；**注意选nums[:]，不然全是一样的**
```python
class Solution: #python的方法
    def permute(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        output = [[i] for i in nums]
        for i in range(n-1):
            output = [i+[j] for i in output for j in nums if j not in i] #if在后不需要else，在前必须else
        return output

class Solution: #递归的方法，回溯法
    def permute(self, nums):
        n = len(nums)
        def traceback(first):
            if first == n:
                res.append(nums[:])
            for i in range(first,n):
                nums[first],nums[i] = nums[i],nums[first] #first后面的全部交换
                traceback(first+1)
                nums[first],nums[i] = nums[i],nums[first] #回溯法，记得换回来
        res = []
        traceback(0)
        return res
```

#### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215192601335.png" alt="image-20201215192601335" style="zoom:50%;" />

> **A:** 转置+倒序
```python
class Solution:
    def rotate(self, matrix):
        n = len(matrix)        
        # transpose matrix
        for i in range(n):
            for j in range(i+1, n):
                matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i] 

        # reverse each row
        for i in range(n):
            matrix[i].reverse()

```

#### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215194030847.png" alt="image-20201215194030847" style="zoom:50%;" />

> **A:** 字母异位词的sorted(list)是相同的，从这点出发即可；另外，从list转到dict哈希表之后速度明显变快
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        n = len(strs)
        sets = {} #hashmap
        output = [] #输出
        k = 0 #记录位置
        for i in range(n):
            str_set = ''.join(sorted(list(strs[i])))
            if  str_set not in sets:
                sets[str_set] = k
                output.append([strs[i]])
                k += 1
            else:
                output[sets[str_set]].append(strs[i])
        return output
```

#### [[动态规划]-53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215155827374.png" alt="image-20201215155827374" style="zoom:50%;" />

> **A:** 动态规划，DP[i]表示以nums[i]为结尾的连续子数组的最大和，递推公式是如果i-1的最大和+nums[i]比nums[i]大，那么nums[i]和前i-1个连起来形成新的连续子列，否则nums[i]单独成为连续子数组
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        #DP[i]表示以nums[i]为结尾的子数组最大和
        n = len(nums)
        dp = [0 for i in range(n+1)]
        r = float('-inf')
        for i in range(1,n+1):
            dp[i] = max(0,dp[i-1]) + nums[i-1]
            r = max(r,dp[i])
        return r
```

#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222141608499.png" alt="image-20201222141608499" style="zoom:50%;" />

> **A:** 贪心算法做，思路是如果能走到某个index，**那么index之前的所有都可以走到**（关键点），因为是一步步走的不能跳跃
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if not nums: return False
        n = len(nums)
        i = 0 #当前位置
        maxi = 0 #能走到的最远位置
        while i <= maxi:
            if maxi >= n-1:
                return True
            maxi = max(maxi,nums[i]+i)
            i += 1
        return False
```

#### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222150159736.png" alt="image-20201222150159736" style="zoom:50%;" />

> **A:** 判断后面区间是否和前面重合即可
```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if len(intervals) == 0: return []
        res = []
        intervals.sort()  # 先按区间左边界值由小到大排序
        for inter in intervals:
            if len(res) == 0 or res[-1][1] < inter[0]:  
                # 如果结果集最后一个元素的右边界比新加入区间的左边界小，直接加入结果集
                res.append(inter)
            else:  # 否则，说明新加入的和结果集最后一个区间有重合，更新区间右边界即可
                res[-1][1] = max(res[-1][1], inter[1])
        return res
```

#### [[动态规划]-62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214151608861.png" alt="image-20201214151608861" style="zoom:50%;" />

> **A:**二维动态规划，状态转移方程比较简单，类似小时候学的最短路径问题，可优化为1D
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        #2D-DP
        # dp = [[1 for i in range(m)] for j in range(n)]
        # for i in range(1,n):
        #     for j in range(1,m):
        #         dp[i][j] = dp[i-1][j] + dp[i][j-1]
        # return dp[-1][-1] 
        dp = [1 for i in range(m)]
        for i in range(1,n):
            for j in range(1,m):
                dp[j] = dp[j] + dp[j-1]
        return dp[-1]
```

#### [[动态规划]-64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214151104745.png" alt="image-20201214151104745" style="zoom:50%;" />

> **A:** 二维动态规划，状态转移方程从左和上更新即可
```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        #2D-DP
        if not grid: return 0
        m,n = len(grid),len(grid[0])
        for i in range(1,n): grid[0][i] += grid[0][i-1]
        for j in range(1,m): grid[j][0] += grid[j-1][0]
        for p in range(1,m):
            for q in range(1,n):
                grid[p][q] += min(grid[p-1][q],grid[p][q-1])
        return grid[-1][-1]
```

#### [[动态规划]-70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214142220061.png" alt="image-20201214142220061" style="zoom:50%;" />

> **A:** 动态规划鼻祖类问题，斐波那契数列
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [1 for i in range(n+1)]
        for i in range(2,n+1):
            dp[i] = dp[i-1]+dp[i-2]
        return dp[-1]
```

#### [[动态规划]-72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222160047147.png" alt="image-20201222160047147" style="zoom:50%;" />

> **A:** 动态规划，看似和1143和583相似，其实不一样；假如当前i和j位置两字符串字母相同，则dpij=dpi-1j-1；若不相同，对单词1有三种操作方法：① 替换i位置的字母使其和单词2j位置的相同，剩下的为dpi-1j-1 + 1 ② 删除i位置字母，为dpi-1j + 1 ③ 添加单词2j位置的字母，结果为dpij-1 + 1，看哪个最小即可。注意初始化
```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        #DP[i][j]表示word1前i个和word2前j个相同，所需要对word1进行的操作所变次数
        m,n = len(word1),len(word2)
        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
        #DP[0][j]和DP[j][0]表示从空字符串到word2，以及从word1到空字符串的数量
        dp[0] = [i for i in range(n+1)]
        for j in range(m+1): dp[j][0] = j
        for i in range(1,m+1):
            for j in range(1,n+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1] #若相等就继承
                else:
                    dp[i][j] = min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j]) + 1 #替换、添加[i,j-1]和删除操作的最小值+1
        return dp[-1][-1]
```

#### [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201229153921999.png" alt="image-20201229153921999" style="zoom:50%;" />

> **A:** 两个二分查找先找行，再找列，注意第一个二分查找是找到有序数列中最后一个比target=k小的位置
```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        #两个二分查找
        m,n = len(matrix),len(matrix[0])
        #先确定行，在确定列
        s1 = [matrix[i][0] for i in range(m)]
        r = self.bs(s1,target)
        c = self.bs(matrix[r],target)
        if matrix[r][c] == target: return True
        else: return False
    
    def bs(self,seq,k): #二分查找
        n = len(seq)
        l,r = 0,n-1
        while l <= r:
            mid = l + (r-l)//2
            if seq[mid] == k: return mid
            elif seq[mid] > k: r = mid-1
            else: l = mid+1
        return r
```

#### [75*^. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222163838247.png" alt="image-20201222163838247" style="zoom:50%;" />

> **A:** 题目不难，但是一次遍历不容易想到，双指针分别代指0和2的位置，遇到0往前送，遇到2往后送，注意遇到2比较特殊，因为有可能原来位置也是2（故采用while），0则不存在这种情况
```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        #要求T:ON和S:O1，双指针
        n = len(nums)
        if n < 2: return
        l,r,i = 0,n-1,0
        while i <= r:
            while nums[i] == 2 and i <= r: #i不能超过r，因为r之后的都是分好的
                nums[i],nums[r] = nums[r],nums[i]
                r -= 1
                
            if nums[i] == 0:
                nums[i],nums[l] = nums[l],nums[i]
                l += 1

            i += 1
```

#### [[滑动窗口]-76*^. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223105338312.png" alt="image-20201223105338312" style="zoom:50%;" />

> **A:** 题目是滑动窗口（思想就是求以s所有index为起点包含t的最短长度），但是滑动窗口的部分不难，难的是如果判断更新要求，故额外增加一个counter来表示是否包含了字符串t，见[题解](https://leetcode-cn.com/problems/minimum-window-substring/solution/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/)
```python
class Solution:
    def minWindow(self, s: 'str', t: 'str') -> 'str':
        from collections import defaultdict
        lookup = defaultdict(int) #这种字典如果没有key，默认查询值为0
        for c in t:
            lookup[c] += 1 #生成需要的字典，表示当前滑动窗口还需的字符，如果值为小于等于0说明多余，故最后只需判断==0的
        start = 0
        end = 0
        min_len = float("inf")
        counter = len(t) #利用counter记录是否子串包含t
        res = ""
        while end < len(s):
            if lookup[s[end]] > 0:
                counter -= 1
            lookup[s[end]] -= 1
            end += 1
            while counter == 0: #counter等于0说明没有需要的字符
                if min_len > end - start:
                    min_len = end - start
                    res = s[start:end]
                if lookup[s[start]] == 0:
                    counter += 1
                lookup[s[start]] += 1
                start += 1
        return res
```

#### [[回溯]-78. 子集](https://leetcode-cn.com/problems/subsets/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223111357707.png" alt="image-20201223111357707" style="zoom:50%;" />

> **A:** 回溯法和python方法，回溯法的专题看[这里](https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/)
```python
class Solution: #python方法，新元素在旧的基础上加
    def subsets(self, nums: List[int]) -> List[List[int]]:
        if not nums: return []
        n = len(nums)
        output = [[],[nums[0]]]
        for i in range(1,n):
            output += [x+[nums[i]] for x in output]
        
        return output

    
class Solution: #回溯法，弄完了就pop
    def subsets(self, nums: List[int]) -> List[List[int]]:

        def tb(sub,index):
            res.append(sub[:])
            for i in range(index,n):
                sub.append(nums[i])
                tb(sub,i+1) #每一个元素进入sub之后，代表sub之前的元素都用过了
                sub.pop()
        n = len(nums)
        res = []
        tb([],0)
        return res
```

#### [[回溯]-79^*. 单词搜索](https://leetcode-cn.com/problems/word-search/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223142814018.png" alt="image-20201223142814018" style="zoom:50%;" />

> **A:** 回溯法，如果board\[i\]\[j\]==word[k]则继续找四个方向是否可以往下走（不行就退回即回溯），直到走到字符串word的尽头；temp也可以放在外面，每次pop，会快一些
```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        #回溯法
        directions = [(0,1),(1,0),(-1,0),(0,-1)]
        temp = []
        l,m,n = len(word),len(board),len(board[0])

        def tb(i,j,k):#ij代表当前board位置，k代表word位置
            if i<0 or j<0 or i > m-1 or j > n-1: return False
            if word[k] != board[i][j]: return False
            if k == l-1: return True
            temp.append((i,j))
            for di,dj in directions:
                if (i+di,j+dj) not in temp and tb(i+di,j+dj,k+1): return True
            temp.pop()
            return False
        
        for i in range(m):
            for j in range(n):
                if tb(i,j,0): return True
        return False
```

#### [[单调栈]-84*. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223153822541.png" alt="image-20201223153822541" style="zoom:50%;" />

> **A:** 单调递增栈，第一思考，范围宽度*范围内的最小值为面积；第二思考，对于某一根柱子来说，以他为高的最大面积来自于左右第一个比他小的柱子的位置，即heights[index]\*(right-left-1)
```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        #第一思考，范围*范围内的最小值为面积
        #第二思考，对于某一根柱子来说，以他为高的最大面积来自于左右第一个比他小的柱子的位置
        #故维护一个单调递增栈
        maxarea = 0
        stack = []
        n = len(heights)
        for i in range(n):
            right = i #右边比stack内小的位置必定是i
            while stack and heights[stack[-1]] > heights[i]:
                index = stack.pop()
                left = stack[-1] if stack else -1 #左边就必定是栈顶的下一个元素，如果栈空为-1
                maxarea = max(maxarea,heights[index]*(right-left-1))
            stack.append(i)
        right = n
        while stack:
            index = stack.pop()
            left = stack[-1] if stack else -1
            maxarea = max(maxarea,heights[index]*(right-left-1))
        return maxarea
```

#### [85*. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223182609359.png" alt="image-20201223182609359" style="zoom:50%;" />

> **A:** 这个题目还有更简单的方法，现在只能理解这一种，先按行找到每个点为右下角可能的最大矩形，然后按列找真正的最大矩形
```python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        maxarea = 0

        dp = [[0] * len(matrix[0]) for _ in range(len(matrix))]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == '0': continue

                # compute the maximum width and update dp with it
                width = dp[i][j] = dp[i][j-1] + 1 if j else 1

                # compute the maximum area rectangle with a lower right corner at [i, j]
                for k in range(i, -1, -1):
                    width = min(width, dp[k][j])
                    maxarea = max(maxarea, width * (i-k+1))
        return maxarea
```

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> **Q:** 

中序遍历

> **A:** 
```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        stack,p,res = [],root,[]
        while stack or p:
            #对当前结点，要一直往左走直到没有左儿子，然后入栈
            while p:
                stack.append(p)
                p = p.left
            #这时出来的P就是当前结点最左边的左儿子，将他的值放进res，然后遍历他的右子树，此时如果没有右子树，则新P为NONE，下一个P就是stack.pop()，也就是当前结点的父亲，实现回溯
            p = stack.pop()
            res.append(p.val)
            p = p.right
        return res
```

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213120731988.png" alt="image-20201213120731988" style="zoom:50%;" />

> **A:** 动态规划做，找到更新公式
```python
class Solution:
    def numTrees(self, n: int) -> int:
        #DP[i]表示i个节点种数，(DP[0]*DP[i-1])+(DP[1]*DP[i-2])+...+(DP[i-2]*DP[1])+(DP[i-1]*DP[0])
        dp = [0 for i in range(n+1)]
        dp[0] = dp[1] = 1
        for i in range(2,n+1):
            for j in range(i):
                dp[i] += dp[i-j-1]*dp[j]
        return dp[-1]
```

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213132158453.png" alt="image-20201213132158453" style="zoom:50%;" />

> **A:** 二叉搜索树中序遍历有序，从这点判断即可
```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack,temp,p = [],float('-inf'),root
        while stack or p:
            while p:
                stack.append(p)
                p = p.left
            p = stack.pop()
            if p.val > temp: temp = p.val
            else: return False
            p = p.right

        return True
```

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209185219453.png" alt="image-20201209185219453" style="zoom:50%;" />

> **A:** 递归和迭代，迭代就用层序遍历但是要一次输入输出两个节点对应左右两个子树
```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        #题目定的空树也为True，不知为何
        if not root: return True
        return self.comPare(root.left,root.right)
    #递归比较根节点的左右子树是否为镜像
    def comPare(self,p,q):
        if not p and not q: return True
        if not p or not q: return False
        if p.val == q.val: return self.comPare(p.left,q.right) and self.comPare(p.right,q.left)
        else: return False
        
        #层序遍历BFS
        if not root or (not root.left and not root.right): return True
        if not root.left or not root.right: return False
        queue = [(root.left,root.right)]
        while queue:
            n1,n2 = queue.pop(0)
            if not n1 and not n2: continue
            if not n1 or not n2 or n1.val != n2.val: return False
            queue.append((n1.left,n2.right))
            queue.append((n1.right,n2.left))
        
        return True
```


#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209141440946.png" alt="image-20201209141440946" style="zoom:50%;" />

> **A:** 层序遍历，同时记录当前层数depth，和curdep比较，不一样了说明进入下一层
```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        queue,output,curdep = [(root,0)],[[]],0
        while queue:
            node,depth = queue.pop(0)
            if depth == curdep: output[curdep].append(node.val)
            else: 
                curdep += 1
                output.append([node.val])
            if node.left: queue.append((node.left,depth+1))
            if node.right: queue.append((node.right,depth+1))
        return output
```

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213132629521.png" alt="image-20201213132629521" style="zoom:50%;" />

> **A:** 递归简单一些，递归的方法都可以用层序遍历做
```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        # if not root: return 0
        # return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1
        # 层序遍历，先进先出，队列
        if not root: return 0
        queue = [(root,1)]
        while queue:
            node,depth = queue.pop(0)
            if node.left: queue.append((node.left,depth+1))
            if node.right: queue.append((node.right,depth+1))
        return depth
```

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213135313850.png" alt="image-20201213135313850" style="zoom:50%;" />

> **A:** 前序=根+左子树+右子树；中序=左子树+根+右子树；找到根，确定左右子树的前中序，递归下去就行
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        #找到根节点和左右子树，递归
        if not preorder: return 
        root = TreeNode(preorder[0])
        leftlen = inorder.index(root.val) #左子树结点数
        root.left = self.buildTree(preorder[1:leftlen+1],inorder[:leftlen])
        root.right = self.buildTree(preorder[leftlen+1:],inorder[leftlen+1:])
        return root
```

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209154834106.png" alt="image-20201209154834106" style="zoom:50%;" />

> **A:** 递归简单一些，递归的方法都可以用层序遍历做
```python
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        #没想到递归只想到了层序遍历，第二次想到了递归
        if not root: return False
        queue = [(root,root.val)]
        while queue:
            node,pathsum = queue.pop(0)
            if node.left: queue.append((node.left,pathsum+node.left.val))
            if node.right: queue.append((node.right,pathsum+node.right.val))
            if not node.left and not node.right and pathsum == sum: return True
        return False
        
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
            if not root: return False
            if not root.left and not root.right and sum - root.val == 0:return True
            return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)
```

#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213140958755.png" alt="image-20201213140958755" style="zoom:50%;" />

> **A:** 顺序是按照前序遍历，之后全放在右子树上；改进算法是在前序遍历的过程中构建链表，之前output.append(p.val)改为构建链表
```python
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        stack,p,pre = [],root,None
        while stack or p:
            while p:
                stack.append(p.right)
                if pre:
                    pre.left = None
                    pre.right = p
                pre = p
                p = p.left
            p = stack.pop()
        
        return root
```

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215160807578.png" alt="image-20201215160807578" style="zoom:50%;" />

> **A:** 记录minprice，那么当前最大的收益（prices[i] > minprice）就是prices[i]-minprice，否则更新minprice
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices: return 0
        maxp,minprice,n = 0,prices[0],len(prices)
        for i in range(1,n):
            if prices[i] > minprice: maxp = max(maxp,prices[i]-minprice)
            else: minprice = prices[i]
        
        return maxp
```

#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)


> **Q:** 和543求树的直径类似，利用递归过程更新max

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209195056629.png" alt="image-20201209195056629" style="zoom:50%;" />

> **A:** 递归，maxlen计算以当前根节点为起点的max路径和，对于每个根节点来说，最终最大路径就是val+leftmax+rightmax
```python
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.p = float('-inf')
        def maxlen(root):
            if not root: return 0
            left = max(maxlen(root.left),0)
            right = max(maxlen(root.right),0)
            self.p = max(self.p,left+right+root.val)
            return max(left+root.val,right+root.val)
        maxlen(root)
        return self.p
```

#### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226134342810.png" alt="image-20201226134342810" style="zoom:50%;" />


> **A:** hashmap简化查询，同时利用查询hm[j-1]是否存在的方法消除冗余
```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        #hashmap
        n = len(nums)
        from collections import defaultdict
        hm = defaultdict(int)
        for i in nums: hm[i] = 1
        mp = 0
        for j in nums:
            start = j
            if hm[j-1] == 0:
                while hm[j] == 1:
                    j += 1
                mp = max(mp,j-start)
        return mp
```

#### [[位运算]-136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226143459675.png" alt="image-20201226143459675" style="zoom:50%;" />


> **A:** 自己的想法是集合*2-列表，用位运算可以将空间优化到O(1)。
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return sum(set(nums))*2-sum(nums)

class Solution: #位运算
    def singleNumber(self, nums: List[int]) -> int:
        n = len(nums)
        output = nums[0]
        for i in range(1,n):
            output ^= nums[i]
        return output
```

#### [[完全背包]-139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215152231138.png" alt="image-20201215152231138" style="zoom:50%;" />

> **A:** 完全背包问题但是数据结构变化了，dp[i]表示s[0:i]是否能用wordDict表示，递推公式为遍历j有(dp[j] and s[j:i] in wordDict) or dp[i]。这个题目有顺序的情况下，不能直接套用完全背包问题。这个人总结的不错[这里](https://leetcode-cn.com/problems/word-break/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-we-4/)
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:   
        n = len(s)
        dp = [False for i in range(n+1)]
        dp[0] = True
        for i in range(1,n+1):
            for j in range(0,i):
                dp[i] = dp[j] and s[j:i] in wordDict or dp[i]
        return dp[-1]
```

#### [[链表]-141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226144858817.png" alt="image-20201226144858817" style="zoom:50%;" />

> **A:** 如何判断是否为环，快慢指针，快的如果能和慢的相等说明存在环（即超了一圈儿），且由于速度是1和2故必定会相遇
```python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        #快慢指针
        f,s = head,head
        while f:
            s = s.next
            f = f.next
            if f: 
                f = f.next
                if f == s: return True
        return False
```

#### [[链表]-142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226152735343.png" alt="image-20201226152735343" style="zoom:50%;" />

> **A:** 类似141，当快慢指针相遇时，从头节点开始一个新的指针n，当n和s再次相遇即为环头，证明见[这里](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/)
```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        s = f = head
        while f and f.next:
            s = s.next
            f = f.next.next
            if s == f: break
        else: return #表示没环
        n = head #新指针从头走起，直到和慢指针在环头相遇
        while s != n:
            s,n = s.next,n.next
        return s
```

#### [[链表（双向）]-*146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226155557914.png" alt="image-20201226155557914" style="zoom:50%;" />

> **A:** 用一个history数组来记录已有数据的使用历史，每次get需要将get的key放在数组最后（表示最新使用），此时如果put超过了capacity直接pop数组的最前面的数据（表示最old未使用），同样的put也要更改history（老元素移动到最后，新元素直接加）；但是思路限制在了数组上，查找数组元素是O(N)的复杂度，所以不对，要使用双向链表并用hashmap存储节点位置和对应的值，此时查询一个具体的key的复杂度才能达到O(1)。
```python
class LRUCache:

    def __init__(self, capacity: int):
        self.d = {}
        self.history = []
        self.capacity = capacity


    def get(self, key: int) -> int:
        if self.d.get(key): 
            new = self.history.pop(self.history.index(key)) #更新为new放在history最后
            self.history.append(new)
            return self.d[key]
        else: return -1

    def put(self, key: int, value: int) -> None:
        if self.d.get(key):
            self.history.append(self.history.pop(self.history.index(key))) #更新为new放在history最后
            self.d[key] = value
        else:
            if len(self.history) == self.capacity: #数组满了，需要pop最old的数据
                old = self.history.pop(0)
                self.d.pop(old)
            self.history.append(key)
            self.d[key] = value
```

#### [[链表]-147*. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226170737969.png" alt="image-20201226170737969" style="zoom:50%;" />

> **A:** 思路没问题，具体实现要考虑特殊情况，我的想法是保留已有序链表的起始和结尾节点l和r（必须要保留r否则会出错），然后n表示要排序的节点；记得要把每次排好序的链表和之后没排序的链表连接起来，即去掉此次排序过程中排进去的节点n
```python
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        if not head or not head.next: return head
        dummy = ListNode()
        dummy.next = head
        l,r,n = dummy,head,head.next
        while n:
            f = n.next #保存下下一个节点，最后更新n用
            while l.next.val < n.val: #找到比n大的节点的前一个节点
                l = l.next
            if l == r: #如果最后到了r，说明n比之前的全都大，直接令r=n即可
                r = n
            else: #否则正常改动即可，若n比所有的都小，则l是dummy不变，一样直接改动即可
                n.next = l.next
                l.next = n
            r.next = f #记得去掉原来位置的节点，这一步很关键
            l,n = dummy,f #更新l和n，r在之前已经更新过了
        return dummy.next
```

#### [[链表]148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227140705645.png" alt="image-20201227140705645" style="zoom:50%;" />

> **A:** 归并排序，注意细节
```python
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        #NlogN的三种：归并、堆和快速排序
        #找到中点，排序左右子列，然后merge两个有序列表
        #注意，要分mid前的子列时，需要有tail的概念，故写个inner
        def inner(head,tail): #这个tail是到不了的，左闭右开
            if not head:
                return head
            if head.next == tail: #加这一步很关键，因为是左闭右开，故tail和head直接连接时相当于只有head，输出即可
                head.next = None
                return head
            slow = fast = head #否则就是常规的找中点
            while fast != tail and fast.next != tail:
                slow = slow.next
                fast = fast.next.next
            mid = slow
            return self.merge(inner(head, mid), inner(mid, tail))

        return inner(head,None)
    
    def merge(self,l1,l2):
        dummy = ListNode()
        node = dummy
        while l1 and l2:
            if l1.val <= l2.val:
                node.next = l1
                l1 = l1.next
            else:
                node.next = l2
                l2 = l2.next
            node = node.next
        if l1: node.next = l1
        if l2: node.next = l2
        return dummy.next
```

#### [[动态规划]-152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227145009849.png" alt="image-20201227145009849" style="zoom:50%;" />

> **A:** 动态规划，考虑到负数的存在，要找以当前nums[i]结尾的连乘的max和min的两个累计值，然后递推一致；可以优化到1D
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        #两个DP同时记录以数字i为结尾的最小乘积和最大乘积
        if not nums: return 0
        n = len(nums)
        adp = [1 for i in range(n)]
        idp = [1 for i in range(n)]
        adp[0] = idp[0] = nums[0]
        for i in range(1,n):
            if nums[i] >= 0: #可以优化到1D
                adp[i] = max(adp[i-1]*nums[i],nums[i])
                idp[i] = min(idp[i-1]*nums[i],nums[i])
            else:
                adp[i] = max(idp[i-1]*nums[i],nums[i])
                idp[i] = min(adp[i-1]*nums[i],nums[i])
        return max(adp)          
    
class Solution: #1D
    def maxProduct(self, nums: List[int]) -> int:
        #同时记录最大和最小两个DP
        n = len(nums)
        dp = (nums[0],nums[0])
        maxp = nums[0]
        for i in range(1,n):
            if nums[i] >= 0:
                maxone = max(dp[0]*nums[i],nums[i])
                minone = min(dp[1]*nums[i],nums[i])
            else:
                maxone = max(dp[1]*nums[i],nums[i])
                minone = min(dp[0]*nums[i],nums[i])      
            maxp = max(maxp,maxone)
            dp = (maxone,minone)         
        return maxp 

```

#### [[堆栈]-155. 最小栈](https://leetcode-cn.com/problems/min-stack/)


> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227150531802.png" alt="image-20201227150531802" style="zoom:50%;" />

> **A:** 这次做想多了，考虑到栈的特点，后入栈的比当前最小值i大的元素都不用记录，因为他们肯定比最小值i先出栈
```python
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.minv = []

    def push(self, x: int) -> None:
        self.stack.append(x)
        if not self.minv or x <= self.minv[-1]: self.minv.append(x) #只有新入栈元素比最小值小才需记录

    def pop(self) -> None:
        out = self.stack.pop()
        if out == self.minv[-1]: self.minv.pop()
        return out

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minv[-1] if self.minv else None
```

#### [[链表]-160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213114036501.png" alt="image-20201213114036501" style="zoom:50%;" />

> **A:** 将两个链表连在一起，这样最后总会遍历到相同点，这一思想被236所采纳，即序列尾部相同找相同点
```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        l1,l2 = headA,headB
        while l1!=l2:
            l1 = l1.next if l1 else headB
            l2 = l2.next if l2 else headA
        return l1
```

#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227151337268.png" alt="image-20201227151337268" style="zoom:50%;" />

> **A:** hashmap或投票法，核心思想是大于一半的众数只有一个
```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        if not nums: return
        n = len(nums)
        k = n//2+1
        from collections import defaultdict
        hm = defaultdict(int)
        for i in range(n):
            hm[nums[i]] += 1
            if hm[nums[i]] == k: return nums[i]
#投票法candi代表选举人，count代表票数，票数为0换人，相同的+1不同的-1
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        candi = 0
        count = 0
        for n in nums:
            if count == 0: candi = n
            if candi == n: count += 1
            elif candi != n: count -= 1
        return candi
```

#### [[位运算]-191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201230161822512.png" alt="image-20201230161822512" style="zoom:50%;" />

> **A:** n和n-1的**与**运算会把n的最后一个1去掉，去掉一个1就output+=1，直到n为0，这个算法叫做**布赖恩·克尼根算法**；[python位运算](https://www.runoob.com/python/python-operators.html)
```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        output = 0
        while n != 0:
            n &= n-1
            output += 1
        return output
```

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214142845928.png" alt="image-20201214142845928" style="zoom:50%;" />

> **A:** 动态规划
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        #DP
        if not nums: return 0
        n = len(nums)
        dp = [0 for i in range(n+1)]
        dp[1] = nums[0]
        for i in range(2,n+1):
            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1])
        return dp[-1]
#简化到O(1)空间
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums: return 0
        n = len(nums)
        a,b = 0,nums[0]
        for i in range(2,n+1):
            temp = max(a+nums[i-1],b)
            a,b = b,temp
        return b
```

#### [*200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227153007857.png" alt="image-20201227153007857" style="zoom:50%;" />

> **A:** DFS，要理解什么是岛屿，见[这里](https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)
```python
class Solution:
    def dfs(self, grid, r, c):
        grid[r][c] = 0
        nr, nc = len(grid), len(grid[0])
        for x, y in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:
            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == "1":
                self.dfs(grid, x, y)

    def numIslands(self, grid: List[List[str]]) -> int:
        nr = len(grid)
        if nr == 0:
            return 0
        nc = len(grid[0])

        num_islands = 0
        for r in range(nr):
            for c in range(nc):
                if grid[r][c] == "1":
                    num_islands += 1
                    self.dfs(grid, r, c)
        
        return num_islands
```

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213142201635.png" alt="image-20201213142201635" style="zoom:50%;" />

> **A:** 反转链表竟然忘了，牢记！分对儿进行，记录next并反转，直到cur是None
```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre,cur = None,head
        while cur != None:
            temp = cur.next
            cur.next = pre
            pre,cur = cur,temp
        return pre
```

#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201216110515560.png" alt="image-20201216110515560" style="zoom:50%;" />

> **A:** 堆排序，建立最大堆；快速排序，平均复杂度均为O(NlogN)，空间复杂度为O(1)
```python
class Solution:
    def findKthLargest(self, nums, k: int) -> int:
        heap = self.make_heap(nums)
        for i in range(k):
            output,heap = self.heappop(heap)
        return output
    #最大堆的建立
    def make_heap(self,seq):
        n = len(seq)
        first = n//2 - 1 #第一个父节点的索引、
        for parent in range(first,-1,-1):
            seq = self.check(seq,parent)
        return seq
    #最大堆pop操作，即输出最大值    
    def heappop(self,seq):
        if not seq: return 
        if len(seq) == 1: return seq[0],[]
        output = seq[0]
        seq[0] = seq.pop()
        seq = self.check(seq,0)
        return output,seq
    #最大堆过滤操作
    def check(self,seq,parent):
        n = len(seq)
        while 2*(parent+1)-1 < n:
            child = 2*(parent+1)-1
            if child < n-1 and seq[child] < seq[child+1]:
                child += 1
            if seq[parent] < seq[child]:
                seq[parent],seq[child] = seq[child],seq[parent]
                parent = child
            else: break
        return seq
#快速排序    
class Solution:
    def findKthLargest(self, nums, k: int) -> int:
        n = len(nums)
        return self.quick_sort(nums)[n-k]

    def quick_sort(self,seq):
        n = len(seq)
        if n <= 1: return seq
        def inner(seq,l,r):
            if r-l < 2: 
                seq[l],seq[r] = sorted([seq[l],seq[r]])
                return seq
            mid = (l+r)//2
            seq[l],seq[mid],seq[r] = sorted([seq[l],seq[mid],seq[r]])
            seq[r-1],seq[mid] = seq[mid],seq[r-1]
            i,j,prior = l+1,r-2,seq[r-1] #只需要管l+1->r-2
            while True:
                while seq[i] <= prior and i < r-1: i += 1 #左指针不能超过主元的位置
                while seq[j] > prior: j -= 1
                if i > j: break
                seq[i],seq[j] = seq[j],seq[i]
            seq[i],seq[r-1] = seq[r-1],seq[i]
            inner(seq,l,i-1)
            inner(seq,i+1,r)
            return seq
        return inner(seq,0,n-1)
```

#### [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223164540702.png" alt="image-20201223164540702" style="zoom:50%;" />

> **A:** 动态规划，如果i,j是1则以i,j为右下角的正方形取决于dp\[i - 1\]\[j\], dp\[i\]\[j - 1\], dp\[i - 1\]\[j - 1\]的min+1，否则肯定为0
```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]: return 0
        #DP[i][j]代表以i,j为右下角的矩阵的最大正方形的边长
        m,n = len(matrix), len(matrix[0])
        dp = [[0]*n for _ in range(m)]
        maxlen = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]) + 1
                    maxlen = max(maxlen,dp[i][j])
        return maxlen**2
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

> **Q:**

翻转二叉树

> **A:** 递归简单一些，递归的方法都可以用层序遍历做
```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        #递归
        if not root: return
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left,root.right = right,left
        return root
        #迭代，层序遍历
        if not root: return root
        queue = [root]
        while queue:
            node = queue.pop(0)
            left,right = node.left,node.right
            if left: queue.append(left)
            if right: queue.append(right)
            node.left,node.right = right,left
        return root
```

#### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201228114256290.png" alt="image-20201228114256290" style="zoom:50%;" />

> **A:** O(1)的空间复杂度要把链表一分为二，然后逆转后半段和前半段比较
```python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        new = self.reversel(self.findmid(head))
        while new:
            if new.val == head.val:
                new = new.next
                head = head.next
            else: return False
        return True
    #找中点，偶数找右边，奇数找中点右边
    def findmid(self,head):
        s,f = head,head
        while f:
            s = s.next
            f = f.next
            if f: f = f.next
        return s
    #反转链表
    def reversel(self,p):
        pre,cur = None,p
        while cur:
            temp = cur.next
            cur.next = pre
            pre,cur = cur,temp
        return pre
```

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213112920703.png" alt="image-20201213112920703" style="zoom:50%;" />

> **A:** 迭代的思想最后来源于160链表公共点，序列尾部相同的查找
```python
class Solution: #层序遍历生成路径进行对比
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        #层序遍历记录父节点
        if not root: return
        fathers = {root:None}
        queue = [root]
        while queue:
            node = queue.pop(0)
            if node.left:
                fathers[node.left] = node
                queue.append(node.left)
            if node.right:
                fathers[node.right] = node
                queue.append(node.right)
        l1,l2 = p,q
        while l1!=l2:
            l1 = fathers.get(l1) if l1 else q #或者写为fathers.get(l1,q)
            l2 = fathers.get(l2) if l2 else p #fathers.get(l2,p)
        return l1
#递归，如果左右子树都找到了那么就说明root是最近        
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return None
        if root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left and right:
            return root
        return left if left else right
```

#### [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201228120038315.png" alt="image-20201228120038315" style="zoom:50%;" />

> **A:** 两次遍历找到nums[i]左边所有数乘积和右边，然后L[i]*R[i]即可
```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        L,R,output = [1 for i in range(n)],[1 for i in range(n)],[1 for j in range(n)]
        for x in range(1,n):
            L[x] = L[x-1] * nums[x-1]
        for y in range(n-2,-1,-1):
            R[y] = R[y+1] * nums[y+1]
        for j in range(n):
            output[j] = L[j]*R[j]
        return output
#优化到O1空间复杂度
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        output = [1 for i in range(n)]
        for i in range(1,n):
            output[i] = output[i-1] * nums[i-1] #左边所有数的乘积
        R = 1 #用于累积右边所有数乘积
        for j in range(n-1,-1,-1):
            output[j] *= R #乘以右边所有数
            R *= nums[j] #更新R
        return output
```

#### [*239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

> **Q:**



> **A:** 找固定区间内的最值，第一时间想到分桶法，见官方解法3；用双向队列做了出来，思路是：l和r控制窗口大小，维护一个单调递减的栈，因为一旦有新的更大的元素入栈（说明这个元素满足滑动窗口长度），之前的比它小的都没用了（肯定在一个区间内），以此类推，当r和l的距离达到k时最大值即为队首元素。
```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        queue,output = [],[]
        l = r = 0
        while r < n:
            while queue and nums[queue[-1]] <= nums[r]:
                queue.pop()
            queue.append(r)
            if r-l == k-1:
                while queue[0] < l: queue.pop(0)
                output.append(nums[queue[0]])
                l += 1
            r += 1     
        return output
```

#### [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201230153412893.png" alt="image-20201230153412893" style="zoom:50%;" />

> **A:** 可以按照对角线进行对行和列的二分搜索，复杂度O(logn!)；或者找左下角和右上角，然后比较更新i,j即可
```python
class Solution:
    def searchMatrix(self, matrix, target):
        #找左下角和右上角，左上角和右下角不行，是min和max
        
        #选左上角，往右走和往下走都增大，不能选

        #选右下角，往上走和往左走都减小，不能选

        #选左下角，往右走增大，往上走减小，可选

        #选右上角，往下走增大，往左走减小，可选
        if not matrix: return False
        m, n = len(matrix), len(matrix[0])
        i, j = m-1, 0
        while i >= 0 and j < n:
            if target > matrix[i][j]: j += 1
            elif target < matrix[i][j]: i -= 1
            else: return True
        return False
```

#### [[动态规划]-279*. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201229143126100.png" alt="image-20201229143126100" style="zoom:50%;" />

> **A:** 动态规划，dp[i]找之前所有dp[j]的最小个数，记得保存下平方和的数组，不用每次都计算了；更优化的方法是完全背包问题，每个数x的价值为1，重量为x**2，找到恰好把背包装满的价值最小的方法
```python
class Solution:
    def numSquares(self, n: int) -> int:
        if n <= 2: return n
        square_nums = [i**2 for i in range(0, int(math.sqrt(n))+2)]
        dp = [float('inf') for i in range(n+1)]
        dp[0],dp[1] = 0,1
        for i in range(2,n+1):
            k = 1
            while square_nums[k] <= i:
                dp[i] = min(dp[i],dp[i-square_nums[k]]+1)
                k += 1
        return dp[-1]
#完全背包
class Solution:
    def numSquares(self, n: int) -> int:
        m = int(n**0.5)
        dp = list(range(n+1))
        for i in range(1, m):
            cur = (i + 1) ** 2
            for j in range(cur, n+1):
                dp[j] = min(dp[j], dp[j-cur] + 1)
        return dp[-1]
```

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201229142856221.png" alt="image-20201229142856221" style="zoom:50%;" />

> **A:** 两种思路，一种是遍历然后遇到的第j个非零数就和j位置上的元素交换；第二种是双指针，l找0，r找l后面的非零，然后交换
```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        l = r = 0
        while l < n-1:
            while l < n-1 and nums[l] != 0: l += 1
            r = max(r,l)
            while r < n-1 and nums[r] == 0: r += 1
            nums[l],nums[r] = nums[r],nums[l]
            l += 1

    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        j = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[j] , nums[i]= nums[i] , nums[j]
                j += 1
```

#### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201229140541160.png" alt="image-20201229140541160" style="zoom:50%;" />

> **A:** 类似141，142环形链表，名字叫Floyd 判圈算法，当链表中存在环，快慢指针相遇的地方重新令n=0，n和s再次相遇就是环入口
```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        #快慢指针
        f = s = 0 #重复数字的地方会形成环
        while s == 0 or f != s:
            f = nums[nums[f]]
            s = nums[s]
        n = 0
        while n != s:
            s = nums[s]
            n = nums[n]
        return s
```

#### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213143410812.png" alt="image-20201213143410812" style="zoom:50%;" />

> **A:** 层序遍历编码，之后再层序遍历解码
```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root: return "[]"
        queue = collections.deque()
        queue.append(root)
        res = []
        while queue:
            node = queue.popleft()
            if node:
                res.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
            else: res.append("null")
        return '[' + ','.join(res) + ']'


    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if data=='[]':
            return None
        vals, i = data[1:-1].split(','), 1
        root = TreeNode(int(vals[0]))
        queue = collections.deque()
        queue.append(root)
        while queue:
            node = queue.popleft()
            if vals[i] != "null":
                node.left = TreeNode(int(vals[i]))
                queue.append(node.left)
            i += 1
            if vals[i] != "null":
                node.right = TreeNode(int(vals[i]))
                queue.append(node.right)
            i += 1
        return root
```

#### [[动态规划]-300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213171048192.png" alt="image-20201213171048192" style="zoom:50%;" />

> **A:** [答案分析](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/yi-bu-yi-bu-tui-dao-chu-guan-fang-zui-you-jie-fa-x/)，将问题转化为维护一个数组，然后可以利用二分法（也可以不用二分法暴力求解都行），但是要理解如何转化的；同样的问题还有[646. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)，也可以利用维护一个最佳数组解出来 p.s.:用DP也可以做，但是复杂度是ON2
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        #维护一个虚拟递增数组，新进来的找位置即可
        n = len(nums)
        tmp = [nums[0]]
        for i in range(1,n):
            index = self.bi_search(tmp,nums[i])
            if index >= len(tmp): tmp.append(nums[i])
            else: tmp[index] = nums[i]
        return len(tmp)
	# 通用二分查找
    def bi_search(self,tmp,target):
        l,r = 0,len(tmp)-1
        while l <= r:
            mid = l + (r-l) // 2
            if tmp[mid] < target:
                l = mid+1
            elif tmp[mid] > target:
                r = mid-1
            else: return mid
        return l

    
#DP硬做
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1 for i in range(n)] #dp[i]表示前i+1的最长子序列
        for i in range(1,n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i],dp[j]+1)
        return max(dp)
```

#### [[完全背包]-322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215143513776.png" alt="image-20201215143513776" style="zoom:50%;" />

> **A:** 第一种方法是最朴素的想法（这种一定要掌握，记得初始化要对，第一行全是0，第一列全是inf想象成0个硬币去拟合k需要无穷个），第二个是完全背包问题的解答（即第一种方法中`f[i][j]`只和上一层一个状态 (`f[i-1]f[j]`) 和这一层的一个状态 `(f[i][j-c]+1)` 有关。可以将状态优化为**一维数组**），见[这里](https://leetcode-cn.com/problems/coin-change/solution/yong-bei-bao-wen-ti-si-xiang-lai-li-jie-ying-bi-zh/)，思想不同于01背包，即第k轮更新后面的时候需要前面已经更新好了，故正序
```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if not coins: return -1
        n = len(coins)
        dp = [[float('inf') for i in range(amount+1)] for j in range(n+1)]
        #dp[0][0]代表没有硬币组成0需要0个硬币，dp[0]代表没有硬币组成k需要无穷个，dp[i][0]代表i个硬币组成0需要0
        for i in range(n+1): dp[i][0] = 0
        for i in range(1,n+1):
            for j in range(1,amount+1):
                if j < coins[i-1]: dp[i][j] = dp[i-1][j]
                else: dp[i][j] = min(dp[i-1][j],dp[i][j-coins[i-1]]+1)
        return dp[-1][-1] if dp[-1][-1] < float('inf') else -1
    
class Solution: #第一种方法的1D优化版
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf') for i in range(amount+1)]
        dp[0] = 0
        for coin in coins:
            for j in range(coin,amount+1):
                dp[j] = min(dp[j],dp[j-coin]+1)
        return dp[-1] if dp[-1] < float('inf') else -1
```

#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209205439079.png" alt="image-20201209205439079" style="zoom:50%;" />

> **A:** 类似124，543和687，迭代过程中更新max但返回值不同；可以不用self.p，因为根肯定是最大的值；动态规划的方法以后可以学
```python
class Solution:
    def rob(self, root: TreeNode) -> int:
        #返回偷与不偷的最值，返回两个主要是为了写递归
        def inner(root):
            if not root: return 0,0
            lt,lnt = inner(root.left)
            rt,rnt = inner(root.right)
            #当前节点偷
            t = root.val+lnt+rnt
            #当前节点不偷
            nt = max(lt,lnt)+max(rt,rnt)
            return t,nt
        return max(inner(root))
```

#### [[位运算]-338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215140236457.png" alt="image-20201215140236457" style="zoom:50%;" />

> **A:** 可以采取从0-num的191的挨个计算，我是找规律做的
```python
class Solution:
    def countBits(self, num: int) -> List[int]:
        if num == 0: return [0]
        import math
        k = int(math.log2(num))+1
        output = [0,1]
        for i in range(k-1):
            output += [x+1 for x in output] #找规律从0,1开始，后面的是前面的+1
        return output[:num+1]
```

#### [[堆栈]-394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210101165136330.png" alt="image-20210101165136330" style="zoom:50%;" />

> **A:** 堆栈思想，分情况判断
```python
#https://blog.csdn.net/lssrain/article/details/88825776 判断字符串为字母or数字
class Solution:
    def decodeString(self, s: str) -> str:
        n = len(s)
        kf,kc,count = [],[],-1 #kf存储字符串重复的次数，kc存储重复字符串的内容，count用来统计次数（防止'100'这样）
        output = ''
        for i in range(n):
            if not kf and s[i].isalpha(): #如果kf空则说明此时没有在[]内，直接放入output
                output += s[i]
            elif s[i].isdigit(): #如果是数字，就要统计出次数（连续数字100这样）
                if count == -1: count = s[i]
                else: count += s[i]
            elif s[i] == '[': #左括号，需要把count变成倍数并push进入kf，同时count复原，kc加入空列表
                kf.append(int(count))
                count = -1
                kc.append([])
            elif s[i] == ']': #右括号，看看kf是否空，空了说明直接加入output，非空加入kc的最后一个中，仍有嵌套
                content = kc.pop() * kf.pop()
                if not kf: output += ''.join(content)
                else: kc[-1] += content
            else: #单纯的字母直接加入kc最后一个
                kc[-1].append(s[i])
        return output
```
#### [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210101174646283.png" alt="image-20210101174646283" style="zoom:50%;" />

> **A:** 两种方法：1.递归，找到0的最小身高k，必在第一个位置，之后所有比k矮的-1继续递归即可，记得1加回来；2. 按身高逆序，前人数升序，然后直接一个fo循环即可
```python
class Solution: #递归
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        n = len(people)
        if n < 2: return people
        mint,pop = float('inf'),0
        for i in range(n):
            if people[i][1] == 0 and mint > people[i][0]:
                mint = people[i][0]
                k = i
        people.pop(k)
        for j in range(n-1):
            if people[j][0] <= mint: people[j][1] -= 1
        new = self.reconstructQueue(people)
        for j in range(n-1):
            if new[j][0] <= mint: new[j][1] += 1        
        return [[mint,0]]+new

class Solution: #排序
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        n = len(people)
        people = sorted(people,key = lambda x:(-x[0],x[1]))
        new = []
        for i in range(n):
            k = people[i][1]
            if k != i:
                new.insert(k,people[i])
            else: new.append(people[i])
        return new
```

#### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209174432896.png" alt="image-20201209174432896" style="zoom:50%;" />

> **A:** 和112路经总和原理类似，可以在那个的基础上递归做，也可以采用层序遍历的方法
```python
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> int:
        #层序遍历带东西，前序遍历也可以
        if not root: return 0
        queue,res = [(root,[root.val])],0
        while queue:
            node,arr = queue.pop(0)
            res += arr.count(sum)
            arr.append(0)
            if node.left:
                temp = [x+node.left.val for x in arr]
                queue.append((node.left,temp))
            if node.right:
                temp = [x+node.right.val for x in arr]
                queue.append((node.right,temp))
        return res
```

#### [[滑动窗口]-438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210101180356064.png" alt="image-20210101180356064" style="zoom:50%;" />

> **A:** 类似78，简化版，一起复习
```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        res = []
        if len(p) > len(s):     
            return res
        dic = {}
        m = len(p)
        count = m
        for i in range(m):
            dic[p[i]] = dic.get(p[i], 0) +1   #记录所需元素及个数
        i = 0
        while i < len(s):
            if s[i] in dic:              
                dic[s[i]] -= 1               #如果S[i]在dic中存在，更新值
                if dic[s[i]] >= 0:           #如果dic[s[i]]<0,表明不需要这个数，不能更新count
                    count -= 1
            if i >= m:                       # 当i>=m, 弹出失效的字符，保证长度相等
                if s[i-m] in dic:
                    dic[s[i-m]] += 1        #s[i-m]未必一定在dic中，需要判断
                    if dic[s[i-m]] > 0:     #需要的数被弹出，更新count
                        count += 1
            if count == 0:
                res.append(i-m+1)
            i += 1
        return res
```

#### [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201216141031380.png" alt="image-20201216141031380" style="zoom:50%;" />

> **A:** 脑筋急转弯，第一次遍历把|nums[i]|-1位置的数变成负数，第二次遍历只需要找不是负的index就行了
```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums)
        output = []
        for i in range(n):
            index = abs(nums[i])-1
            if nums[index] > 0: nums[index] *= -1
        for j in range(n):
            if nums[j] > 0: output.append(j+1)
        return output
```

#### [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210101182059476.png" alt="image-20210101182059476" style="zoom:50%;" />

> **A:** 通过异或运算先找到所有不同，然后利用191布赖恩·克尼根算法计算位数
```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        nt = x^y #找到不同
        output = 0 #191布赖恩·克尼根算法计算位数
        while nt != 0:
            nt &= nt-1
            output += 1
        return output
```

#### [[背包问题]-494. 目标和](https://leetcode-cn.com/problems/target-sum/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215141443346.png" alt="image-20201215141443346" style="zoom:50%;" />

> **A:** 思路同416背包问题，将问题转化为从数列中找到和为num的子列，这个题是求数量；P.S.:注意判断S>数组和的情况，不然超时
```python
class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -> int:
        #同样转化为目标和
        if not nums: return 0
        s,n = sum(nums),len(nums)
        if (s+S)%2 == 1 or S > s: return 0
        target = (s+S)//2
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        #01背包问题模板
        for i in range(n):
            for j in range(target,nums[i]-1,-1):
                dp[j] += dp[j-nums[i]]
        return dp[-1]
```

#### [*538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213155534005.png" alt="image-20201213155534005" style="zoom:50%;" />

> **A:** 二叉搜索树的中序遍历有序，逆中序遍历为倒序（右-根-左），不断累加bigger和node.val相加即可
```python
class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        #反向中序遍历右-根-左
        stack,p,bigger = [],root,0
        while stack or p:
            while p:
                stack.append(p)
                p = p.right
            p = stack.pop()
            p.val += bigger #每次加bigger
            bigger = p.val #每次更新bigger
            p = p.left
        return root
```

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

> **Q:**

![image-20201209143206148](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209143206148.png)

> **A:** 思路依然是求二叉树深度（递归），类似124，543和687，迭代过程中更新max但返回值不同

```python
class Solution:
    def __init__(self,):
        self.p = 0
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        
        def inner(root):
            if not root: return 0
            left = inner(root.left)
            right = inner(root.right)
            self.p = max(self.p,left+right) #left,right是节点个数，直径=节点数-1，故不用算root
            return max(left,right)+1
        
        inner(root)

        return self.p
```

#### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210102154340607.png" alt="image-20210102154340607" style="zoom:50%;" />

> **A:** j-i的连续子序列和可以表示为[0,i]-[0,j-1]，故我们只需要收集0-n-1的所有子序列和，之后做差即可，用hashmap可以优化，key是和的值，value是取该和的子序列个数

```python
class Solution:
    def subarraySum(self, nums, k):
        dic = {}
        dic[0] = 1
        total = count = 0
        for i in range(len(nums)):
            total += nums[i]
            if total - k in dic:
                count += dic[total - k]
            dic[total] = dic.get(total, 0) + 1
        return count
```

#### [572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209180411271.png" alt="image-20201209180411271" style="zoom:50%;" />

> **A:** 一棵子树上的点在 DFS 序列（即先序遍历）中是连续的，但是要注意空子树用*代替，每条子树开头+#以防[12]和[2]这样的树

```python
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        ss = self.preorder(s)
        st = self.preorder(t)
        print(st,ss)
        return st in ss
        
    def preorder(self,root):
        stack,output = [root],""
        while stack:
            node = stack.pop()
            if node: 
                output += '#'+str(node.val)
                stack.append(node.right)
                stack.append(node.left)
            else: output += '*'

        return output
#递归的方法，内部递归函数鉴定两棵树是否一致，灵感来源于剑指26
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:

        if not s: return False

        def recur(p1,p2):
            if not p1 and not p2: return True
            if not p1 or not p2: return False
            if p1.val != p2.val: return False
            else: return recur(p1.left,p2.left) and recur(p1.right,p2.right)
        
        return recur(s,t) or self.isSubtree(s.left,t) or self.isSubtree(s.right,t)
```

#### [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210102163540289.png" alt="image-20210102163540289" style="zoom:50%;" />

> **A:** 1. 排序后比较第一个和最后一个位置不对的left和right 2. 找到**最短子序列中**最小值和最大值需要安放的地方即可
```python
class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        sort_nums = sorted(nums)
        left = 0
        right = len(nums) - 1
        while left <= right and nums[left] == sort_nums[left]:
            left += 1
        while left <= right and nums[right] == sort_nums[right]:
            right -= 1
        return right - left + 1
```

#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209154239131.png" alt="image-20201209154239131" style="zoom:50%;" />

> **A:** 递归的方法都可以用层序遍历做
```python
class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
        if not t1: return t2
        if not t2: return t1
        t1.val = t1.val + t2.val
        t1.left = self.mergeTrees(t1.left,t2.left)
        t1.right = self.mergeTrees(t1.right,t2.right)
        return t1
```

#### [[动态规划]-647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210102165555536.png" alt="image-20210102165555536" style="zoom:50%;" />

> **A:** 思路同5最长回文子串，记录个数即可，动态规划
```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        #同最长回文子串，DP[i][j]表示长度为i+1的从j开始的是否为回文子串
        n = len(s)
        dp = [[False]*n for _ in range(n+1)]
        dp[0] = dp[1] = [True]*n
        r = n
        for i in range(2,n+1):
            for j in range(n-i+1):
                if s[j] == s[j+i-1] and dp[i-2][j+1]:
                    dp[i][j] = True
                    r += 1
        return r
```

#### [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

> **Q:**

![image-20201209203844677](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209203844677.png)

> **A:** 类似124和543两道题目，递归的过程中更新max但是递归返回值不同于max，思考见[github](https://github.com/zjuzhfbloodz/LeetCode/blob/master/leetcode-algorithms/687.%20Longest%20Univalue%20Path/0687.md)很清楚
```python
class Solution:
    def longestUnivaluePath(self, root: TreeNode) -> int:
        self.p = 0
        
        def inner(root):
            if not root: return 0
            if not root.left and not root.right: return 1
            ml,mr = 0,0 #ml和mr是为了后面判断更方便，即ml>0说明左子树和根相等，否则说明不等
            left = inner(root.left)
            right = inner(root.right)
            if root.left and root.left.val == root.val:
                ml += left
            if root.right and root.right.val == root.val:
                mr += right
            self.p = max(self.p,ml+mr)
            if ml > 0 and mr > 0: return max(ml,mr)+1
            else: return ml+mr+1

        inner(root)
        return self.p
```

#### [[哈希]-771. 宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210102170218865.png" alt="image-20210102170218865" style="zoom:50%;" />

> **A:** Hashmap两次遍历即可
```python
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        dic,output = {},0
        for s in stones:
            if dic.get(s): dic[s] += 1
            else: dic[s] = 1
        for j in jewels:
            output += dic.get(j,0)
        return output
```

#### [[动态规划]-1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222153914181.png" alt="image-20201222153914181" style="zoom:50%;" />

> **A:** 动态规划，如果text1[i] == text2[j]，则DP要更新，否则选最大的；[583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)，思路一致，求得公共子串后即得
```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        #DP[i][j]表示text1的前i个字符和text2的前j个字符的最长子序列长度
        m,n = len(text1),len(text2)
        dp = [[0]*(n+1) for i in range(m+1)]
        for i in range(1,m+1):
            for j in range(1,n+1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])
        return dp[-1][-1]
```