[TOC]

### 一些思想

#### 1. 动态规划问题搞清楚或记牢DP代表的含义，之后对应的转移方程其实迎刃而解了
> 包含问题：5-10-39-42-53-55-62-96-152-221-279-300-647-1143共14题


#### 2. 背包问题通解：

- 完全背包问题，按先硬币后数值的双循环**正序**更新1D的dp

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        for c in candidates: #先硬币
            for i in range(c,target+1): #后数值
                dp[i] += dp[i-c]
        return dp[-1]
```

- 01背包问题，按先硬币后数值的双循环**逆序**更新1D的dp
```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        for c in candidates: #先硬币
            for i in range(target,c-1,-1): #后逆序数值
                dp[i] += dp[i-c]
        return dp[-1]
```
#### 3. 链表问题，针对边界值的特殊情况，加一个dummy会好很多
> 包含问题：19-
#### 4. Python基础操作

- 堆[heapq](https://www.jianshu.com/p/801318c77ab5)

```python
import heapq
heap = heapq.heappush(heap,value) #添加元素
heap = heapq.heappop(heap) #pop最小值，最大堆可以全加负号
#创建heap
#第一种
nums = [2, 3, 5, 1, 54, 23, 132]
heap = []
for num in nums:
    heapq.heappush(heap, num)  # 加入堆

print(heap[0])  # 如果只是想获取最小值而不是弹出，使用heap[0]
print([heapq.heappop(heap) for _ in range(len(nums))])  # 堆排序结果
# out: [1, 2, 3, 5, 23, 54, 132]

# 第二种
nums = [2, 3, 5, 1, 54, 23, 132]
heapq.heapify(nums)
print([heapq.heappop(nums) for _ in range(len(nums))])  # 堆排序结果
# out: [1, 2, 3, 5, 23, 54, 132]
```

- 集合set+列表list+字典

```python
a,b = set(),[1,2,3]
a.add(1) #新增
a.remove(1) #删除元素，不要用pop，是随机的
1 in a == True
b.index(1) == 0
b.remove(1) #删除值为1的元素
#生成字典的方式，字典只有pop没有remove
for i in p:
    letters[i] = letters.get(i,0) + 1
```

- 队列[deque](https://www.cnblogs.com/ranzhong/p/12438841.html)

```python
#python3目前不用import包
掌握append,pop,popleft即可，还可以extend([1,2,3])
```



#### 5. 滑动窗口

思想：用双指针i,j表示滑动窗口的左边界和右边界，通过改变i,j来扩展和收缩滑动窗口，可以想象成一个窗口在字符串/数组上游走，当这个窗口包含的元素满足题目条件时，记录下当前状态，之后继续更新i和j找到新的满足状态。



#### 6. 单调栈

如下代码是739每日温度的解答，是一个标准的单调栈，类似的问题还有42接雨水，84/85最大面积矩形

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        #维护一个单调递减的栈
        n = len(temperatures)
        stack = []
        output = [0 for _ in range(n)]
        for i in range(n):
            while stack and temperatures[stack[-1]] < temperatures[i]:
                index = stack.pop()
                output[index] = i-index
            stack.append(i)
        return output
```





#### 7. 题目考察网站

https://codetop.cc/#/home

### 题目

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

> **Q:** HashMap

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201022220130608.png" alt="image-20201022220130608" style="zoom:50%;" />

> **A:** 可以用字典加速达到O(N)，继续优化就是一边更新字典一边选，选到了直接output
```python
class Solution:
    def twoSum(self, nums, target):
        #用字典来加速查询
        dik = {}
        for i in range(len(nums)):
            if dik.get(target - nums[i]) is not None: #找到了就输出
                return([dik[target - nums[i]],i])
            dik[nums[i]] = i #加入新元素
```


#### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

> **Q:** Linked List

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201022222353644.png" alt="image-20201022222353644" style="zoom:50%;" />

> **A:**
```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy,head,r = ListNode(),ListNode(),0
        dummy.next = head
        while l1 or l2 or r: #r是余数，只要还有l1l2或r就要继续增加节点
            n1 = l1.val if l1 else 0
            n2 = l2.val if l2 else 0
            num,r = (n1 + n2 + r) % 10,(n1 + n2 + r) // 10
            head.next = ListNode(num)
            head = head.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None

        return dummy.next.next
```


#### [[滑动窗口]-3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

> **Q:** Dual Pointer

![text](https://github.com/zjuzhfbloodz/LeetCode/raw/master/questions/0003.png?raw=true)

> **A:** 双指针模拟滑动窗口；我用的字典记录字符和位置，遇到相同的直接将位置之前的所有都pop即可（更快）
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        #思路是双指针，或者叫滑动窗口
        i,j,maxlen = 0,0,0

        while j < len(s): #后面的指针不能超过s长度
            if s[j] not in s[i:j]: #没重复，j向后
                j += 1
            else:
                maxlen = max(maxlen,j-i)   #重复了，更新最值，i向后，直到没有重复之前j不变
                i += 1     
                #i += s[i:j].find(s[j]) + 1  #没有提升多少，迅速更新最新i到和j重复的字符之后
                 
        return max(maxlen,j-i) #防止全不同的序列没有更新过
#优化方法   
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s: return 0
        history = dict()
        output = 0
        n = len(s)
        start = 0
        for i in range(n):
            if s[i] in history:
                output = max(output,len(history))
                index = history[s[i]]
                for j in range(start,index+1):
                    history.pop(s[j])
                start = index+1
            history[s[i]] = i
        return max(output,len(history))
```

#### [4*^. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

> **Q:** Recursion

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201023183841426.png" alt="image-20201023183841426" style="zoom:50%;" />

> **A:** 本质上是两个有序数组中找第k小的数
```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        #技巧使代码更统一精简，如果两个数组长度和是奇数，那么k1=k2，计算均值同偶数形式不用改写了
        n1,n2 = len(nums1),len(nums2)
        k1 = (n1+n2+1) // 2
        k2 = (n1+n2+2) // 2
        #本质上是两个有序数组中找第k小的数
        def inner(l1,l2,k):
            
            if len(l1) < len(l2): l1,l2 = l2,l1#保持nums1比较长
            if len(l2) == 0: return l1[k-1] #即当nums2走到尽头的时候，直接返回
            if k == 1: return min(l1[0],l2[0]) #找最小数，比较数组首位
            t = min(k//2,len(l2)) # t每次是要找的位数的1/2，这样使复杂度达到log，且保证不上溢
            if l1[t-1] >= l2[t-1]: return inner(l1,l2[t:],k-t) #这里是t意味前k//2个都不能要
            else: return inner(l1[t:],l2,k-t)

        return (inner(nums1,nums2,k1)+inner(nums1,nums2,k2)) / 2

```

#### [[动态规划]-5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

> **Q:** Dynamic Programming

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201024173612969.png" alt="image-20201024173612969" style="zoom:50%;" />

> **A:** 按回文串的长度x进行逐步DP动态规划，长度为3的依靠长度为1的，长度为5的依靠长度为3的，依次类推；类似题目647
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        #DP[i][j]表示从s[j]开始的长度为i的字符串是否为回文
        if not s: return ''
        n = len(s)
        dp = [[False]*n for i in range(n+1)]
        dp[0] = [True]*n
        dp[1] = [True]*n
        output = s[0]
        for i in range(2,n+1):
            for j in range(n-i+1):
                if s[j] == s[j+i-1] and dp[i-2][j+1]:
                    dp[i][j] = True
                    output = s[j:j+i]
        return output
```

#### [[动态规划]-10*. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

> **Q:** Dynamic Programming

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201025214110071.png" alt="image-20201025214110071" style="zoom:50%;" />

> **A:** DP动态规划，分p中的字符种类三种情况"x * ."思考转移方程，[解答](https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/)
```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        #match函数用来判断两个字符是否匹配
        def match(i,j):
            if i == 0: return False #当s为空时，显然p[j-1]不能匹配，不用考虑诸如a*的情况，都在dp中包含了
            if p[j-1] == '.': return True
            return s[i-1] == p[j-1]
        #DP[i][j]表示s的前i个字符和p的前j个字符是否匹配
        m,n = len(s),len(p)
        dp = [[False]*(n+1) for i in range(m+1)]
        dp[0][0] = True
        for i in range(m+1):
            for j in range(1,n+1):
                if p[j-1] == '*': #如果为*有两种情况，抛去前两个和i匹配，或者如果相等就和i-1继续匹配
                    dp[i][j] = dp[i][j-2]
                    if match(i,j-1):
                        dp[i][j] = dp[i][j-2] or dp[i-1][j]
                else: #否则只能看是否相等
                    if match(i,j):
                        dp[i][j] = dp[i-1][j-1]
        return dp[-1][-1]

```

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

> **Q:** Dual Pointer

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201026150625433.png" alt="image-20201026150625433" style="zoom:50%;" />

> **A:** 头尾双指针，每次的area结果都是当前所有边中和短边构成面积的max，之后即可舍弃该短边，即短边索引+1或-1
```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # 对于每一个坐标i，他所能构成的area的max高度是自己的高度
        # area = (j-i) * min(height[j],height[i])，依然是双指针
        i,j,maxarea = 0,len(height)-1,0
        while i != j:
            if height[i] <= height[j]:
                area = height[i] * (j-i)
                i += 1
            else:
                area = height[j] * (j-i)
                j -= 1
            maxarea = max(maxarea,area)
                
        return maxarea
```

#### [15*. 三数之和](https://leetcode-cn.com/problems/3sum/)

> **Q:** HashMap or Sort

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201027215546487.png" alt="image-20201027215546487" style="zoom:50%;" />

> **A:** 可以用hashmap类似第1题中的操作将复杂度降到O(N2)但判断更难，也可以使用排序的方法，更巧妙一些，**重点在于不要重复**
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        #排序+双指针
        output,n = [],len(nums)
        nums = sorted(nums)
        for i in range(n): #遍历每个点i，从i+1到n-1，找和可以为0且不重复的（因为有序）
            if nums[i] > 0: break #如果当前都大于0了，之后的不可能和为0
            if i > 0 and nums[i] == nums[i-1]: continue #重复的也要跳过
            l,r = i+1,n-1 #满足条件的开始循环找，和大于0，右端往左，否则左端往右，=0要注意不能和上一次的重复并移动双指针
            while l < r:
                sum3 = nums[i] + nums[l] + nums[r]
                if sum3 < 0: l += 1 
                elif sum3 > 0: r -= 1
                else:
                    if r == n-1 or (nums[l-1] != nums[l] or nums[r+1] != nums[r]):
                        output.append([nums[i],nums[l],nums[r]])
                    l,r = l+1,r-1
                    
        return output
```

#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

> **Q:** HashMap

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201028205544281.png" alt="image-20201028205544281" style="zoom:50%;" />

> **A:** 利用hashmap+回溯backtrack
```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: return []
        n = len(digits)
        dictionary = {'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}
        output = []
        r = []
        def traceback(index):
            if index == n:
                output.append(''.join(r))
                return
            word = dictionary[digits[index]]
            for w in word:
                r.append(w)
                traceback(index+1)
                r.pop()
        traceback(0)
        return output
```

#### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

> **Q:** Linked List

![image-20201029203546392](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201029203546392.png)

> **A:** 不用空节点的话，如果只有一个head且n=1没法执行，最后记得return dummy.next（也是为了特殊情况）
```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        #双指针，加一个空头不用判断特殊情况（即删除头节点的情况）
        dummy = ListNode(next=head)
        l = r = dummy
        for i in range(n+1): r = r.next
        while r:
            l,r = l.next,r.next
        l.next = l.next.next
        return dummy.next
```

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

> **Q:** Stack

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201109194515530.png" alt="image-20201109194515530" style="zoom:50%;" />

> **A:** 难度不大，使用stack先进后出即可
```python
class Solution:
    def isValid(self, s: str) -> bool:
        #先进后出stack，注意右括号是不能进入stack的，进入了就说明False
        n = len(s)
        stack = []
        r = {'[':']','{':'}','(':')'}
        for i in range(n):
            if s[i] in r:
                stack.append(s[i])
            else:
                if not stack or r[stack[-1]] != s[i]:
                    return False
                else:
                    stack.pop()
        #还剩元素说明肯定不匹配
        return True if not stack else False
```

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

> **Q:** Linked List and Dual Pointer

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201109195701797.png" alt="image-20201109195701797" style="zoom:50%;" />

> **A:** 依次比较大小生成新链表即可
```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        #双指针
        dummy = ListNode()
        head = dummy
        while l1 and l2:
            if l1.val >= l2.val:
                head.next = l2
                l2 = l2.next
            else:
                head.next = l1
                l1 = l1.next
            head = head.next
        if l1: head.next = l1
        if l2: head.next = l2

        return dummy.next
```

#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

> **Q:** STACK or Dynamic Programming

![image-20201112200640224](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201112200640224.png)

> **A1:** 括号类问题都要遵守的规则：一个有效的组合的前任意个元素中，右括号不能多于左括号的个数
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        #n个'('和n个')'，且一个有效的组合的前任意个元素中，右括号不能多于左括号的个数
        output = ["("]
        counts = [(1,0)] #count用于记录目前output的所有元素中左右括号的个数，随output更新
        for i in range(2*n-1):
            length = len(output)
            for j in range(length):
                old,c = output.pop(0),counts.pop(0)
                if c[0] < n:#左括号不能超过n,此时可以添加左括号
                    output.append(old+'(')
                    counts.append((c[0]+1,c[1]))
                if c[1] < c[0]: #左括号比右括号多的时候可以添加右括号
                    output.append(old+')')
                    counts.append((c[0],c[1]+1))
        return output
```


#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

> **Q:** Heap or N Pointers

![image-20201204165107243](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201204165107243.png)

> **A:** 最小堆，复杂度nklog(k)，先将k个序列的第一个结点构成一个logk深度的最小堆，然后pop最小值，如果该节点还有next，将next入堆，继续做即可，每个节点入堆一次出堆一次（复杂度为log(k))，总计复杂度为nklog(k)
```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        import heapq
        heap = [] #堆
        n = len(lists)
        dummy = ListNode()
        p = dummy
        for i in range(n):
            if lists[i]:
                heapq.heappush(heap,(lists[i].val,i))
                lists[i] = lists[i].next
        while heap:
            value,index = heapq.heappop(heap)
            p.next = ListNode(val = value)
            p = p.next
            if lists[index]:
                heapq.heappush(heap,(lists[index].val,index))
                lists[index] = lists[index].next
        return dummy.next
```

#### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

> **Q:** 

![image-20201205145502711](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201205145502711.png)

> **A:** 找到从右到左的第一个逆序数列，这个数列无法通过交换两个数的位置得到下一个字典序，故需要更新序列前面的数字即可
```python
class Solution:
    def nextPermutation(self, nums) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k = n-1
        while k != 0 and nums[k] <= nums[k-1]: #找到从右到左的第一个逆序数列
            k -= 1
        nums[k:] = nums[k:][::-1] #将其逆转，并交换第一个大于前面数的序列中的数
        for i in range(k,n):
            if nums[i] > nums[k-1]:
                nums[i],nums[k-1] = nums[k-1],nums[i]
                break
```

#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

> **Q:**

![image-20201205173138334](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201205173138334.png)

> **A:** DP[i]表示前i个字符的括号个数，更新看i和i-1位置上的括号情况；栈的方法是匹配左右括号，多余的右括号起到了分割字符串的作用，即多余右括号之前的字符串都不能再算入了，问题的关键是右括号
```python
#动态规划
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        dp = [0 for i in range(n+1)]
        for i in range(2,n+1):
            if s[i-1] == ')':
                if s[i-2] == '(':
                    dp[i] = dp[i-2] + 2
                elif i-dp[i-1]-2 >= 0 and s[i-dp[i-1]-2] == '(':
                    dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2
        return max(dp)
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        #维护一个栈，栈底元素是最后一个未匹配的右括号的位置，用来分割字符串
        n = len(s)
        stack= [-1]
        output = 0
        for i in range(n):
            if s[i] == '(':
                stack.append(i)
            else:
                stack.pop()
                if stack:
                    output = max(output,i-stack[-1])
                else:
                    stack.append(i)
        return output 
```

#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

> **Q:** 二分搜索

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201207193822281.png" alt="image-20201207193822281" style="zoom:50%;" />

> **A:** 二分查找，但是l和r的状态更新有了变化，选择左区间(nums[l],target,nums[mid])有三种可能[4,5,7],[7,8,1],[7,1,2]，注意等号
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        #二分查找，状态更新有区别
        n = len(nums)
        l,r = 0,n-1
        while l <= r:
            mid = l + (r-l)//2 #二分
        #左区间(nums[l],target,nums[mid])有三种可能[4,5,7],[7,8,1],[7,1,2]
            if nums[mid] == target: return mid
            elif nums[l] <= target < nums[mid] or nums[mid] < nums[l] <= target or target < nums[mid] < nums[l]:
                r = mid - 1
            else:
                l = mid + 1
        return -1
```

#### [[完全背包]-39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215173114825.png" alt="image-20201215173114825" style="zoom:50%;" />

> **A:** 完全背包问题，第一种方法是朴素思想，第二种是优化到1D
```python
class Solution:
    def combinationSum(self, candidates, target: int):
        #完全背包问题
        n = len(candidates)
        dp = [[[] for i in range(n+1)] for j in range(target+1)]
        for i in range(1,n+1):
            for j in range(1,target+1):
                dp[j][i] += dp[j][i-1] #无论j和当前硬币的大小，都要将之前的加上
                if j == candidates[i-1]: dp[j][i] += [[candidates[i-1]]]
                if j > candidates[i-1]:
                    dp[j][i] += [x+[candidates[i-1]] for x in dp[j-candidates[i-1]][i]]
        return dp[-1][-1]
    
class Solution: #优化到1D
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        dp = [[] for i in range(target+1)]
        dp[0] = [[]]
        for c in candidates:
            for i in range(c,target+1):
                for combine in dp[i-c]:
                    dp[i].append(combine+[c])
        return dp[-1]
```

#### [[动态规划]-42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222120101668.png" alt="image-20201222120101668" style="zoom:50%;" />

> **A:** 要对每个height[i]找到0-(i-1)的max和(i+1)-(n-1)的max，这两个max中的min决定了height[i]所能接水的量，可以用DP来找；或者是用[巧方法](https://leetcode-cn.com/problems/trapping-rain-water/solution/wei-en-tu-jie-fa-zui-jian-dan-yi-dong-10xing-jie-j/)；DP可以优化到O1的空间复杂度，用双指针[见解答下面Lucien的评论](https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/)，即双指针指代左右两边的max，左边的max对于左边的index是可信的，右边同理，若左max小于右max，则左边index一定由左边决定，否则去看右边，类似84（84是两小夹一大，42是两大夹一小）
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 用两个DP分别记录下标i左边和右边的max，i所能存储的水量就是min(左,右)-height[i]
        n = len(height)
        ldp = [0 for i in range(n)]
        rdp = [0 for i in range(n)]
        output = 0
        for i in range(1,n): ldp[i] = max(ldp[i-1],height[i-1])
        for i in range(n-2,0,-1): 
            rdp[i] = max(rdp[i+1],height[i+1])
            r = min(ldp[i],rdp[i]) - height[i]
            if r > 0:
                output += r
        return output

    
class Solution:
    def trap(self, height: List[int]) -> int:
        #单调递减栈，新的大元素入栈说明和stack[-2]一起可以给stack[-1]位置的元素增加雨水（两大夹一小），如果只剩一个就直接pop
        n = len(height)
        stack = []
        output = 0
        for i in range(n):
            while stack and height[stack[-1]] < height[i]:
                if len(stack) == 1:
                    stack.pop()
                else:
                    index = stack.pop()
                    left = height[stack[-1]]
                    right = height[i]
                    output += (min(left,right) - height[index]) * (i-stack[-1]-1)
            stack.append(i)
        return output
```

#### [[回溯]-46. 全排列](https://leetcode-cn.com/problems/permutations/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214140318038.png" alt="image-20201214140318038" style="zoom:50%;" />

> **A:** 前first-1个数字已经选好，后n-first如何选？就从后面依次和first位置交换（第一次自己和自己交换）即可；**注意选nums[:]，不然全是一样的**
```python
class Solution: #python的方法
    def permute(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        output = [[i] for i in nums]
        for i in range(n-1):
            output = [i+[j] for i in output for j in nums if j not in i] #if在后不需要else，在前必须else
        return output

class Solution: #回溯法
    def permute(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        output = []
        def traceback(index):
            if index == n:
                output.append(nums[:])
                return
            for i in range(index,n):
                nums[i],nums[index] = nums[index],nums[i]
                traceback(index+1)
                nums[i],nums[index] = nums[index],nums[i]
        traceback(0)
        return output
```

#### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215192601335.png" alt="image-20201215192601335" style="zoom:50%;" />

> **A:** 转置+倒序
```python
class Solution:
    def rotate(self, matrix):
        n = len(matrix)        
        # transpose matrix
        for i in range(n):
            for j in range(i+1, n):
                matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i] 

        # reverse each row
        for i in range(n):
            matrix[i].reverse()

```

#### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215194030847.png" alt="image-20201215194030847" style="zoom:50%;" />

> **A:** 字母异位词的sorted(list)是相同的，从这点出发即可；另外，从list转到dict哈希表之后速度明显变快
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        n = len(strs)
        sets = {} #hashmap
        output = [] #输出
        k = 0 #记录位置
        for i in range(n):
            str_set = ''.join(sorted(list(strs[i])))
            if  str_set not in sets:
                sets[str_set] = k
                output.append([strs[i]])
                k += 1
            else:
                output[sets[str_set]].append(strs[i])
        return output
```

#### [[动态规划]-53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215155827374.png" alt="image-20201215155827374" style="zoom:50%;" />

> **A:** 动态规划，DP[i]表示以nums[i]为结尾的连续子数组的最大和，递推公式是如果i-1的最大和+nums[i]比nums[i]大，那么nums[i]和前i-1个连起来形成新的连续子列，否则nums[i]单独成为连续子数组
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        #DP[i]表示以nums[i]为结尾的子数组最大和
        n = len(nums)
        dp = [0 for i in range(n+1)]
        r = float('-inf')
        for i in range(1,n+1):
            dp[i] = max(0,dp[i-1]) + nums[i-1]
            r = max(r,dp[i])
        return r
```

#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222141608499.png" alt="image-20201222141608499" style="zoom:50%;" />

> **A:** 贪心算法做，思路是如果能走到某个index，**那么index之前的所有都可以走到**（关键点），因为是一步步走的不能跳跃
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if not nums: return False
        n = len(nums)
        i = 0 #当前位置
        maxi = 0 #能走到的最远位置
        while i <= maxi:
            if maxi >= n-1:
                return True
            maxi = max(maxi,nums[i]+i)
            i += 1
        return False
```

#### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222150159736.png" alt="image-20201222150159736" style="zoom:50%;" />

> **A:** 判断后面区间是否和前面重合即可
```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if len(intervals) == 0: return []
        res = []
        intervals.sort()  # 先按区间左边界值由小到大排序
        for inter in intervals:
            if len(res) == 0 or res[-1][1] < inter[0]:  
                # 如果结果集最后一个元素的右边界比新加入区间的左边界小，直接加入结果集
                res.append(inter)
            else:  # 否则，说明新加入的和结果集最后一个区间有重合，更新区间右边界即可
                res[-1][1] = max(res[-1][1], inter[1])
        return res
```

#### [[动态规划]-62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214151608861.png" alt="image-20201214151608861" style="zoom:50%;" />

> **A:**二维动态规划，状态转移方程比较简单，类似小时候学的最短路径问题，可优化为1D
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        #2D-DP
        # dp = [[1 for i in range(m)] for j in range(n)]
        # for i in range(1,n):
        #     for j in range(1,m):
        #         dp[i][j] = dp[i-1][j] + dp[i][j-1]
        # return dp[-1][-1] 
        dp = [1 for i in range(m)]
        for i in range(1,n):
            for j in range(1,m):
                dp[j] = dp[j] + dp[j-1]
        return dp[-1]
```

#### [[动态规划]-64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214151104745.png" alt="image-20201214151104745" style="zoom:50%;" />

> **A:** 二维动态规划，状态转移方程从左和上更新即可
```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        #2D-DP
        if not grid: return 0
        m,n = len(grid),len(grid[0])
        for i in range(1,n): grid[0][i] += grid[0][i-1]
        for j in range(1,m): grid[j][0] += grid[j-1][0]
        for p in range(1,m):
            for q in range(1,n):
                grid[p][q] += min(grid[p-1][q],grid[p][q-1])
        return grid[-1][-1]
```

#### [[动态规划]-70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214142220061.png" alt="image-20201214142220061" style="zoom:50%;" />

> **A:** 动态规划鼻祖类问题，斐波那契数列
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [1 for i in range(n+1)]
        for i in range(2,n+1):
            dp[i] = dp[i-1]+dp[i-2]
        return dp[-1]
```

#### [[动态规划]-72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222160047147.png" alt="image-20201222160047147" style="zoom:50%;" />

> **A:** 动态规划，看似和1143和583相似，其实不一样；假如当前i和j位置两字符串字母相同，则dpij=dpi-1j-1；若不相同，对单词1有三种操作方法：① 替换i位置的字母使其和单词2j位置的相同，剩下的为dpi-1j-1 + 1 ② 删除i位置字母，为dpi-1j + 1 ③ 添加单词2j位置的字母，结果为dpij-1 + 1，看哪个最小即可。注意初始化
```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        #DP[i][j]表示word1前i个和word2前j个相同，所需要对word1进行的操作所变次数
        m,n = len(word1),len(word2)
        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
        #DP[0][j]和DP[j][0]表示从空字符串到word2，以及从word1到空字符串的数量
        dp[0] = [i for i in range(n+1)]
        for j in range(m+1): dp[j][0] = j
        for i in range(1,m+1):
            for j in range(1,n+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1] #若相等就继承
                else:
                    dp[i][j] = min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j]) + 1 #替换、添加[i,j-1]和删除操作的最小值+1
        return dp[-1][-1]
```

#### [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201229153921999.png" alt="image-20201229153921999" style="zoom:50%;" />

> **A:** 两个二分查找先找行，再找列，注意第一个二分查找是找到有序数列中最后一个比target=k小的位置
```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        #两个二分查找
        m,n = len(matrix),len(matrix[0])
        #先确定行，在确定列
        s1 = [matrix[i][0] for i in range(m)]
        r = self.bs(s1,target)
        c = self.bs(matrix[r],target)
        if matrix[r][c] == target: return True
        else: return False
    
    def bs(self,seq,k): #二分查找
        n = len(seq)
        l,r = 0,n-1
        while l <= r:
            mid = l + (r-l)//2
            if seq[mid] == k: return mid
            elif seq[mid] > k: r = mid-1
            else: l = mid+1
        return r
```

#### [75*^. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222163838247.png" alt="image-20201222163838247" style="zoom:50%;" />

> **A:** 题目不难，但是一次遍历不容易想到，双指针分别代指0和2的位置，遇到0往前送，遇到2往后送，注意遇到2比较特殊，因为有可能原来位置也是2（故采用while），0则不存在这种情况
```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        #要求T:ON和S:O1，双指针
        n = len(nums)
        if n < 2: return
        l,r,i = 0,n-1,0
        while i <= r:
            while nums[i] == 2 and i <= r: #i不能超过r，因为r之后的都是分好的
                nums[i],nums[r] = nums[r],nums[i]
                r -= 1
                
            if nums[i] == 0:
                nums[i],nums[l] = nums[l],nums[i]
                l += 1

            i += 1
```

#### [[滑动窗口]-76*^. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223105338312.png" alt="image-20201223105338312" style="zoom:50%;" />

> **A:** 题目是滑动窗口（思想就是求以s所有index为起点包含t的最短长度），但是滑动窗口的部分不难，难的是如果判断更新要求，故额外增加一个counter来表示是否包含了字符串t，见[题解](https://leetcode-cn.com/problems/minimum-window-substring/solution/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/)；ij用ij来模拟滑动窗口，先扩大j找到包含t的然后缩小i直到不完全包含t，之后继续扩大j直到n；判断包含需要need和needCnt两个变量
```python
# ij用ij来模拟滑动窗口，先扩大j找到包含t的然后缩小i直到不完全包含t，之后继续扩大j直到n；判断包含需要need和needCnt两个变量
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        #用ij来模拟滑动窗口
        n,m = len(s),len(t)
        if n < m: return ''
        i,j,output = 0,0,(0,n+1)
        need = dict() #生成需要的字典，表示当前滑动窗口还需的字符，如果值为小于等于0说明多余，故最后只需判断==0的
        for w in t:
            if w not in need:
                need[w] = 1
            else:
                need[w] += 1
        needCnt = m #needCnt用来优化查找速度，即每有一个need中>0减少，needCnt就减少1
        while j < n:
            if s[j] in need:
                if need[s[j]] > 0:
                    needCnt -= 1
                need[s[j]] -= 1
            while needCnt == 0: #needCnt等于0说明s[i:j]包含t了
                if j-i < output[1]-output[0]:
                    output = (i,j)
                if s[i] in need:
                    need[s[i]] += 1
                    if need[s[i]] > 0:
                        needCnt += 1
                i += 1
            j += 1
        return s[output[0]:output[1]+1] if output[1] < n else ''

```

#### [[回溯]-78. 子集](https://leetcode-cn.com/problems/subsets/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223111357707.png" alt="image-20201223111357707" style="zoom:50%;" />

> **A:** 回溯法和python方法，回溯法的专题看[这里](https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/)
```python
class Solution: #python方法，新元素在旧的基础上加
    def subsets(self, nums: List[int]) -> List[List[int]]:
        if not nums: return []
        n = len(nums)
        output = [[],[nums[0]]]
        for i in range(1,n):
            output += [x+[nums[i]] for x in output]
        
        return output

    
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        output = []
        r = []
        def traceback(index):
            output.append(r[:])
            for i in range(index,n):
                r.append(nums[i])
                traceback(i+1) #每一个元素进入sub之后，代表sub之前的元素都用过了
                r.pop()
        traceback(0)
        return output
```

#### [[回溯]-79^*. 单词搜索](https://leetcode-cn.com/problems/word-search/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223142814018.png" alt="image-20201223142814018" style="zoom:50%;" />

> **A:** 回溯法，如果board\[i\]\[j\]==word[k]则继续找四个方向是否可以往下走（不行就退回即回溯），直到走到字符串word的尽头；temp也可以放在外面，每次pop，会快一些
```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        #回溯法
        directions = [(0,1),(1,0),(-1,0),(0,-1)]
        l,r,n = len(board),len(board[0]),len(word)
        visited = set() #用set查询是O(1)
        #代表从board的(i,j)出发能否搜索到word[k:]
        def traceback(i,j,k): 
            if i < 0 or j < 0 or i >= l or j >= r: #越界直接False
                return False
            if board[i][j] != word[k]:
                return False
            #除去上述情况，即当前步可以继续往下走，先判断是否走到最后一位了，后更新visited
            if k == n-1:
                return True
    
            visited.add((i,j))
            for di,dj in directions:
                if (i+di,j+dj) not in visited and traceback(i+di,j+dj,k+1):
                    return True
            visited.remove((i,j)) #记得走完这一步退回去
            return False
        for i in range(l):
            for j in range(r):
                if traceback(i,j,0):
                    return True
        return False
```

#### [[单调栈]-84*. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223153822541.png" alt="image-20201223153822541" style="zoom:50%;" />

> **A:** 单调递增栈，**对所有柱子的高度进行遍历**。对于某一根柱子来说，以他为高的最大面积来自于左右第一个比他小的柱子的位置，即heights[index]\*(right-left-1)，类似42（84是两小夹一大，42是两大夹一小）
```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        #单调栈，思想是碰到一个较小的值k后，左侧所有比k大的值都没用了，相对他们来说k就是右侧第一个小值
        heights = [0] + heights + [0] #左加0为的是pop最后一个元素的时候，右加0为的是柱子高度递增不会进入while循环
        n = len(heights)
        stack = []
        output = 0
        for i in range(n):
            while stack and heights[stack[-1]] > heights[i]:
                index = stack.pop()
                left = stack[-1] #当index被pop时，因为栈内单调增，故stack[-1]栈顶就是left小位置，i就是right小的位置
                right = i
                output = max(output,heights[index]*(right-left-1))
            stack.append(i)
        return output
```

#### [85*. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223182609359.png" alt="image-20201223182609359" style="zoom:50%;" />

> **A:** 这个题目还有更简单的方法，现在只能理解这一种，先按行找到每个点为右下角可能的最大矩形，然后按列找真正的最大矩形
```python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        maxarea = 0

        dp = [[0] * len(matrix[0]) for _ in range(len(matrix))]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == '0': continue

                # compute the maximum width and update dp with it
                width = dp[i][j] = dp[i][j-1] + 1 if j else 1

                # compute the maximum area rectangle with a lower right corner at [i, j]
                for k in range(i, -1, -1):
                    width = min(width, dp[k][j])
                    maxarea = max(maxarea, width * (i-k+1))
        return maxarea
    
#利用84中单调栈的解法优化
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]: return 0
        m,n = len(matrix),len(matrix[0])
        #先按列求每个matrix[i][j]为右下角元素的矩阵的可能max行，即matrix[i][j]上侧连续的1的个数
        dp = [[0]*n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    dp[i][j] = dp[i-1][j]+1 if i > 0 else 1
        #每一行作为84的一个列表，遍历即可，复杂度O(nm)
        output = 0
        for i in range(m):
            #print(dp[i])
            output = max(output,self.q84(dp[i]))
        return output
        

    def q84(self,height):
        #两小夹一大，单调递增栈
        height = [0] + height + [0]
        n = len(height)
        stack = []
        output = 0
        for i in range(n):
            while stack and height[stack[-1]] > height[i]:
                index = stack.pop()
                left = stack[-1]
                right = i
                output = max(output,height[index]*(right-left-1))
            stack.append(i)
        return output
```

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> **Q:** 

中序遍历

> **A:** 
```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if not root: return []
        stack = []
        node = root
        output = []
        while stack or node:
            while node:
                stack.append(node)
                node = node.left
#这时出来的P就是当前结点最左边的左儿子，将他的值放进res，然后遍历他的右子树，此时如果没有右子树，则新P为NONE，下一个P就是stack.pop()，也就是当前结点的父亲
            node = stack.pop()
            output.append(node.val)
            node = node.right
        return output
```

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213120731988.png" alt="image-20201213120731988" style="zoom:50%;" />

> **A:** 动态规划做，找到更新公式
```python
class Solution:
    def numTrees(self, n: int) -> int:
        #DP[i]表示i个节点种数，(DP[0]*DP[i-1])+(DP[1]*DP[i-2])+...+(DP[i-2]*DP[1])+(DP[i-1]*DP[0])
        dp = [0 for i in range(n+1)]
        dp[0] = dp[1] = 1
        for i in range(2,n+1):
            for j in range(i):
                dp[i] += dp[i-j-1]*dp[j]
        return dp[-1]
```

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213132158453.png" alt="image-20201213132158453" style="zoom:50%;" />

> **A:** 搜索二叉树中序遍历有序/或者使用递归，注意子树要加minmax限制
```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack,temp,p = [],float('-inf'),root
        while stack or p:
            while p:
                stack.append(p)
                p = p.left
            p = stack.pop()
            if p.val > temp: temp = p.val
            else: return False
            p = p.right

        return True
#递归的方法
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:

        def inner(root,left,right):

            if not root: return True
            if root.left and root.val <= root.left.val: return False
            if root.right and root.val >= root.right.val: return False
            if root.val <= left or root.val >= right: return False
            return inner(root.left,left,root.val) and inner(root.right,root.val,right)

        return inner(root,float('-inf'),float('inf'))
```

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209185219453.png" alt="image-20201209185219453" style="zoom:50%;" />

> **A:** 递归和迭代，迭代就用层序遍历但是要一次输入输出两个节点对应左右两个子树
```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root: return True
        #递归比较根节点的左右子树是否为镜像
        def compare(l,r):
            if not l and not r: return True
            if not l or not r: return False
            if l.val == r.val:
                return compare(l.left,r.right) and compare(l.right,r.left)
            return False

        return compare(root.left,root.right)
        
        #层序遍历BFS
        if not root or (not root.left and not root.right): return True
        if not root.left or not root.right: return False
        queue = [(root.left,root.right)]
        while queue:
            n1,n2 = queue.pop(0)
            if not n1 and not n2: continue
            if not n1 or not n2 or n1.val != n2.val: return False
            queue.append((n1.left,n2.right))
            queue.append((n1.right,n2.left))
        
        return True
```


#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209141440946.png" alt="image-20201209141440946" style="zoom:50%;" />

> **A:** 层序遍历，同时记录当前层数depth，和curdep比较，不一样了说明进入下一层
```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        queue,output,curdep = [(root,0)],[[]],0
        while queue:
            node,depth = queue.pop(0)
            if depth == curdep: output[curdep].append(node.val)
            else: 
                curdep += 1
                output.append([node.val])
            if node.left: queue.append((node.left,depth+1))
            if node.right: queue.append((node.right,depth+1))
        return output
```

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213132629521.png" alt="image-20201213132629521" style="zoom:50%;" />

> **A:** 递归简单一些，递归的方法都可以用层序遍历做
```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        # if not root: return 0
        # return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1
        # 层序遍历，先进先出，队列
        if not root: return 0
        queue = [(root,1)]
        while queue:
            node,depth = queue.pop(0)
            if node.left: queue.append((node.left,depth+1))
            if node.right: queue.append((node.right,depth+1))
        return depth
```

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213135313850.png" alt="image-20201213135313850" style="zoom:50%;" />

> **A:** 前序=根+左子树+右子树；中序=左子树+根+右子树；找到根，确定左右子树的前中序，递归下去就行
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        #找到根节点和左右子树，递归
        if not preorder: return 
        root = TreeNode(preorder[0])
        leftlen = inorder.index(root.val) #左子树结点数
        root.left = self.buildTree(preorder[1:leftlen+1],inorder[:leftlen])
        root.right = self.buildTree(preorder[leftlen+1:],inorder[leftlen+1:])
        return root
```

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209154834106.png" alt="image-20201209154834106" style="zoom:50%;" />

> **A:** 递归简单一些，递归的方法都可以用层序遍历做
```python
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        #没想到递归只想到了层序遍历，第二次想到了递归
        if not root: return False
        queue = [(root,root.val)]
        while queue:
            node,pathsum = queue.pop(0)
            if node.left: queue.append((node.left,pathsum+node.left.val))
            if node.right: queue.append((node.right,pathsum+node.right.val))
            if not node.left and not node.right and pathsum == sum: return True
        return False
        
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
            if not root: return False
            if not root.left and not root.right and sum - root.val == 0:return True
            return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)
```

#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213140958755.png" alt="image-20201213140958755" style="zoom:50%;" />

> **A:** 顺序是按照前序遍历，之后全放在右子树上；还有一种优化O(1)空间的方法，对每个节点如果有左子树就把右子树挂在左子树最右边的节点上
```python
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root: return
        def psearch(root):
            output = []
            stack = []
            node = root
            while stack or node:
                while node:
                    output.append(node)
                    stack.append(node)
                    node = node.left
                node = stack.pop().right
            return output
        nodes = psearch(root)
        for i in range(len(nodes)-1):
            nodes[i].right = nodes[i+1]
            nodes[i].left = None
        nodes[-1].left = None
        nodes[-1].right = None
#优化到O(1)空间        
class Solution:
    def flatten(self, root: TreeNode) -> None:
        curr = root
        while curr:
            if curr.left:
                predecessor = nxt = curr.left
                while predecessor.right:
                    predecessor = predecessor.right #找到最右边的节点
                predecessor.right = curr.right
                curr.left = None
                curr.right = nxt
            curr = curr.right
```

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215160807578.png" alt="image-20201215160807578" style="zoom:50%;" />

> **A:** 记录minprice，那么当前最大的收益（prices[i] > minprice）就是prices[i]-minprice，否则更新minprice
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices: return 0
        maxp,minprice,n = 0,prices[0],len(prices)
        for i in range(1,n):
            if prices[i] > minprice: maxp = max(maxp,prices[i]-minprice)
            else: minprice = prices[i]
        
        return maxp
```

#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)


> **Q:** 和543求树的直径类似，利用递归过程更新max

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209195056629.png" alt="image-20201209195056629" style="zoom:50%;" />

> **A:** 递归，maxlen计算以当前根节点为起点的max路径和，对于每个根节点来说，最终最大路径就是val+leftmax+rightmax
```python
class Solution:
    def __init__(self):
        self.output = float('-inf')
    def maxPathSum(self, root: TreeNode) -> int:
        #构造maxlen函数计算以node为起点的向下的max和，最大路径和就是node.val+leftmax+rightmax
        if not root: return 0
        def maxSum(node):
            if not node: return 0
            left = max(maxSum(node.left),0)
            right = max(maxSum(node.right),0)
            self.output = max(self.output,left+right+node.val)
            return max(left,right)+node.val
        maxSum(root)
        return self.output
```

#### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226134342810.png" alt="image-20201226134342810" style="zoom:50%;" />


> **A:** hashmap简化查询，同时利用查询hm[j-1]是否存在的方法消除冗余
```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        #hashmap
        n = len(nums)
        from collections import defaultdict
        hm = defaultdict(int)
        for i in nums: hm[i] = 1
        mp = 0
        for j in nums:
            start = j
            if hm[j-1] == 0:
                while hm[j] == 1:
                    j += 1
                mp = max(mp,j-start)
        return mp
```

#### [[位运算]-136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226143459675.png" alt="image-20201226143459675" style="zoom:50%;" />


> **A:** 自己的想法是集合*2-列表，用位运算可以将空间优化到O(1)。
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return sum(set(nums))*2-sum(nums)

class Solution: #位运算
    def singleNumber(self, nums: List[int]) -> int:
        n = len(nums)
        output = nums[0]
        for i in range(1,n):
            output ^= nums[i]
        return output
```

#### [[完全背包]-139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215152231138.png" alt="image-20201215152231138" style="zoom:50%;" />

> **A:** 完全背包问题但是数据结构变化了，dp[i]表示s[0:i]是否能用wordDict表示，递推公式为遍历j有(dp[j] and s[j:i] in wordDict) or dp[i]。这个题目有顺序的情况下，不能直接套用完全背包问题。这个人总结的不错[这里](https://leetcode-cn.com/problems/word-break/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-we-4/)
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:   
        n = len(s)
        dp = [False for i in range(n+1)]
        dp[0] = True
        for i in range(1,n+1):
            for j in range(0,i):
                dp[i] = dp[j] and s[j:i] in wordDict or dp[i]
        return dp[-1]
```

#### [[链表]-141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226144858817.png" alt="image-20201226144858817" style="zoom:50%;" />

> **A:** 如何判断是否为环，快慢指针，快的如果能和慢的相等说明存在环（即超了一圈儿），且由于速度是1和2故必定会相遇
```python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        #快慢指针
        f,s = head,head
        while f:
            s = s.next
            f = f.next
            if f: 
                f = f.next
                if f == s: return True
        return False
```

#### [[链表]-142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226152735343.png" alt="image-20201226152735343" style="zoom:50%;" />

> **A:** 类似141，当快慢指针相遇时，从头节点开始一个新的指针n，当n和s再次相遇即为环头，证明见[这里](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/)
```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        s = f = head
        while f and f.next:
            s = s.next
            f = f.next.next
            if s == f: break
        else: return #表示没环
        n = head #新指针从头走起，直到和慢指针在环头相遇
        while s != n:
            s,n = s.next,n.next
        return s
```

#### [[链表（双向）]-*146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226155557914.png" alt="image-20201226155557914" style="zoom:50%;" />

> **A:** 双向链表+哈希表，其中双向链表记录使用历史，哈希表记录key-value。需要做的操作是删除节点+添加头节点（因为添加肯定是history的第一个）
```python
#双向链表+哈希表（字典），其中双向链表记录使用历史，哈希表记录key-value pair
class BiLink:
    def __init__(self,key=0,value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:

    def __init__(self, capacity: int):
        self.cache = dict()
        self.head = BiLink()
        self.tail = BiLink()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.capacity = capacity
        self.size = 0

    def get(self, key: int) -> int:
        if key not in self.cache: return -1
        # 如果 key 存在，先通过哈希表定位，再删除移到头部
        node = self.cache[key]
        self.removeNode(node)
        self.addTohead(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key not in self.cache:
            # 如果 key 不存在，创建一个新的节点
            node = BiLink(key,value)
            # 添加进哈希表
            self.cache[key] = node
            self.size += 1
            # 添加至双向链表的头部
            self.addTohead(node)
            # 如果超出容量，删除双向链表的尾部节点和cache中对应key
            if self.size > self.capacity:
                node = self.removeTail()
                self.cache.pop(node.key)
        else:
            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node = self.cache[key]
            node.value = value
            self.removeNode(node)
            self.addTohead(node)     

    def removeNode(self,node):
        node.prev.next = node.next
        node.next.prev = node.prev
        return node

    def removeTail(self):
        return self.removeNode(self.tail.prev)
    
    def addTohead(self,node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
```

#### [[链表]-147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226170737969.png" alt="image-20201226170737969" style="zoom:50%;" />

> **A:** 加dummy省去判断特殊情况，然后按从小到大的顺序进行插入排序即可
```python
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        if not head or not head.next: return head
        dummy = ListNode(next=head)
        tmp = dummy #每次序列的头
        node = head.next #每次要插入的节点
        head.next = None
        while node:
            while tmp.next and node.val > tmp.next.val: #这里是判断tmp的next，因为要差到tmp后面
                tmp = tmp.next
            #插到tmp后面，同时更新node和tmp
            cur = node.next
            node.next = tmp.next
            tmp.next = node
            node = cur
            tmp = dummy
        return dummy.next
```

#### [[链表]148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227140705645.png" alt="image-20201227140705645" style="zoom:50%;" />

> **A:** 归并排序，注意细节
```python
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        #NlogN的三种：归并、堆和快速排序
        #找到中点，排序左右子列，然后merge两个有序列表
        #需要有tail的概念来完善链表的头尾
        def merge(l1,l2):
            dummy = ListNode()
            head = dummy
            while l1 and l2:
                if l1.val <= l2.val:
                    head.next = l1
                    l1 = l1.next
                else:
                    head.next = l2
                    l2 = l2.next
                head = head.next
            if l1: head.next = l1
            if l2: head.next = l2
            return dummy.next

        def merge_sort(head,tail):
            if not head: return head
            if head.next == tail: #加这一步很关键，因为是左闭右开，故tail和head直接连接时相当于只有head，输出即可
                head.next = None #这一步None很必须
                return head
            #类似归并排序，找中点
            slow,fast = head,head
            while fast != tail and fast.next != tail:
                slow = slow.next
                fast = fast.next.next
            mid = slow
            l1,l2 = merge_sort(head,mid),merge_sort(mid,tail)
            return merge(l1,l2)

        return merge_sort(head,None)
```

#### [[动态规划]-152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227145009849.png" alt="image-20201227145009849" style="zoom:50%;" />

> **A:** 动态规划，考虑到负数的存在，要找以当前nums[i]结尾的连乘的max和min的两个累计值，然后递推一致；可以优化到1D
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        #两个DP同时记录以数字i为结尾的最小乘积和最大乘积
        if not nums: return 0
        n = len(nums)
        adp = [1 for i in range(n)]
        idp = [1 for i in range(n)]
        adp[0] = idp[0] = nums[0]
        for i in range(1,n):
            if nums[i] >= 0: #可以优化到1D
                adp[i] = max(adp[i-1]*nums[i],nums[i])
                idp[i] = min(idp[i-1]*nums[i],nums[i])
            else:
                adp[i] = max(idp[i-1]*nums[i],nums[i])
                idp[i] = min(adp[i-1]*nums[i],nums[i])
        return max(adp)          
    
class Solution: #1D
    def maxProduct(self, nums: List[int]) -> int:
        #同时记录最大和最小两个DP
        n = len(nums)
        dp = (nums[0],nums[0])
        maxp = nums[0]
        for i in range(1,n):
            if nums[i] >= 0:
                maxone = max(dp[0]*nums[i],nums[i])
                minone = min(dp[1]*nums[i],nums[i])
            else:
                maxone = max(dp[1]*nums[i],nums[i])
                minone = min(dp[0]*nums[i],nums[i])      
            maxp = max(maxp,maxone)
            dp = (maxone,minone)         
        return maxp 

```

#### [[栈]-155. 最小栈](https://leetcode-cn.com/problems/min-stack/)


> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227150531802.png" alt="image-20201227150531802" style="zoom:50%;" />

> **A:** 这次做想多了，考虑到栈的特点，后入栈的比当前最小值i大的元素都不用记录，因为他们肯定比最小值i先出栈
```python
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.minstack = []


    def push(self, val: int) -> None:
        if not self.minstack or self.minstack[-1] >= val: #只有新入栈元素比最小值小才需记录
            self.minstack.append(val)
        self.stack.append(val)


    def pop(self) -> None:
        value = self.stack.pop()
        if value == self.minstack[-1]:
            self.minstack.pop()

    def top(self) -> int:
        return self.stack[-1] if self.stack else None


    def getMin(self) -> int:
        return self.minstack[-1]

```

#### [[链表]-160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213114036501.png" alt="image-20201213114036501" style="zoom:50%;" />

> **A:** 将两个链表连在一起，这样最后总会遍历到相同点，这一思想被236所采纳，即序列尾部相同找相同点
```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        l1,l2 = headA,headB
        while l1!=l2:
            l1 = l1.next if l1 else headB
            l2 = l2.next if l2 else headA
        return l1
```

#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227151337268.png" alt="image-20201227151337268" style="zoom:50%;" />

> **A:** hashmap或投票法，核心思想是大于一半的众数只有一个
```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        if not nums: return
        n = len(nums)
        k = n//2+1
        from collections import defaultdict
        hm = defaultdict(int)
        for i in range(n):
            hm[nums[i]] += 1
            if hm[nums[i]] == k: return nums[i]
#投票法candi代表选举人，count代表票数，票数为0换人，相同的+1不同的-1
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        candi = 0
        count = 0
        for n in nums:
            if count == 0: candi = n
            if candi == n: count += 1
            elif candi != n: count -= 1
        return candi
```

#### [[位运算]-191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201230161822512.png" alt="image-20201230161822512" style="zoom:50%;" />

> **A:** n和n-1的**与**运算会把n的最后一个1去掉，去掉一个1就output+=1，直到n为0，这个算法叫做**布赖恩·克尼根算法**；[python位运算](https://www.runoob.com/python/python-operators.html)
```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        output = 0
        while n != 0:
            n &= n-1
            output += 1
        return output
```

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214142845928.png" alt="image-20201214142845928" style="zoom:50%;" />

> **A:** 动态规划
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        #DP
        if not nums: return 0
        n = len(nums)
        dp = [0 for i in range(n+1)]
        dp[1] = nums[0]
        for i in range(2,n+1):
            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1])
        return dp[-1]
#简化到O(1)空间
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums: return 0
        n = len(nums)
        a,b = 0,nums[0]
        for i in range(2,n+1):
            temp = max(a+nums[i-1],b)
            a,b = b,temp
        return b
```

#### [*200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227153007857.png" alt="image-20201227153007857" style="zoom:50%;" />

> **A:** DFS，要理解什么是岛屿，见[这里](https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)
```python
class Solution:
    def dfs(self, grid, r, c):
        grid[r][c] = 0
        nr, nc = len(grid), len(grid[0])
        for x, y in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:
            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == "1":
                self.dfs(grid, x, y)

    def numIslands(self, grid: List[List[str]]) -> int:
        nr = len(grid)
        if nr == 0:
            return 0
        nc = len(grid[0])

        num_islands = 0
        for r in range(nr):
            for c in range(nc):
                if grid[r][c] == "1":
                    num_islands += 1
                    self.dfs(grid, r, c)
        
        return num_islands
```

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213142201635.png" alt="image-20201213142201635" style="zoom:50%;" />

> **A:** 反转链表竟然忘了，牢记！分对儿进行，记录next并反转，直到cur是None
```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre,cur = None,head
        while cur != None:
            temp = cur.next
            cur.next = pre
            pre,cur = cur,temp
        return pre
```

#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201216110515560.png" alt="image-20201216110515560" style="zoom:50%;" />

> **A:** 堆排序，建立最大堆；快速排序，平均复杂度均为O(NlogN)，空间复杂度为O(1)
```python
class Solution:
    def findKthLargest(self, nums, k: int) -> int:
        heap = self.make_heap(nums)
        for i in range(k):
            output,heap = self.heappop(heap)
        return output
    #最大堆的建立
    def make_heap(self,seq):
        n = len(seq)
        first = n//2 - 1 #第一个父节点的索引、
        for parent in range(first,-1,-1):
            seq = self.check(seq,parent)
        return seq
    #最大堆pop操作，即输出最大值    
    def heappop(self,seq):
        if not seq: return 
        if len(seq) == 1: return seq[0],[]
        output = seq[0]
        seq[0] = seq.pop()
        seq = self.check(seq,0)
        return output,seq
    #最大堆过滤操作
    def check(self,seq,parent):
        n = len(seq)
        while 2*(parent+1)-1 < n:
            child = 2*(parent+1)-1
            if child < n-1 and seq[child] < seq[child+1]:
                child += 1
            if seq[parent] < seq[child]:
                seq[parent],seq[child] = seq[child],seq[parent]
                parent = child
            else: break
        return seq
#快速排序    
class Solution:
    def findKthLargest(self, nums, k: int) -> int:
        n = len(nums)
        return self.quick_sort(nums)[n-k]

    def quick_sort(self,seq):
        n = len(seq)
        if n <= 1: return seq
        def inner(seq,l,r):
            if r-l < 2: 
                seq[l],seq[r] = sorted([seq[l],seq[r]])
                return seq
            mid = (l+r)//2
            seq[l],seq[mid],seq[r] = sorted([seq[l],seq[mid],seq[r]])
            seq[r-1],seq[mid] = seq[mid],seq[r-1]
            i,j,prior = l+1,r-2,seq[r-1] #只需要管l+1->r-2
            while True:
                while seq[i] <= prior and i < r-1: i += 1 #左指针不能超过主元的位置
                while seq[j] > prior: j -= 1
                if i > j: break
                seq[i],seq[j] = seq[j],seq[i]
            seq[i],seq[r-1] = seq[r-1],seq[i]
            inner(seq,l,i-1)
            inner(seq,i+1,r)
            return seq
        return inner(seq,0,n-1)
```

#### [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223164540702.png" alt="image-20201223164540702" style="zoom:50%;" />

> **A:** 动态规划，如果i,j是1则以i,j为右下角的正方形取决于dp\[i - 1\]\[j\], dp\[i\]\[j - 1\], dp\[i - 1\]\[j - 1\]的min+1，否则肯定为0
```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]: return 0
        #DP[i][j]代表以i,j为右下角的矩阵的最大正方形的边长
        m,n = len(matrix), len(matrix[0])
        dp = [[0]*n for _ in range(m)]
        maxlen = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]) + 1
                    maxlen = max(maxlen,dp[i][j])
        return maxlen**2
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

> **Q:**

翻转二叉树

> **A:** 递归简单一些，递归的方法都可以用层序遍历做
```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        #递归
        if not root: return
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left,root.right = right,left
        return root
        #迭代，层序遍历
        if not root: return root
        queue = [root]
        while queue:
            node = queue.pop(0)
            left,right = node.left,node.right
            if left: queue.append(left)
            if right: queue.append(right)
            node.left,node.right = right,left
        return root
```

#### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201228114256290.png" alt="image-20201228114256290" style="zoom:50%;" />

> **A:** O(1)的空间复杂度要把链表一分为二，然后逆转后半段和前半段比较
```python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        #找到后半部分链表+翻转后半部分链表+比较前后
        def findhalf(head):
            #要找的是奇数的中点右侧和偶数的右侧
            s,f = head,head
            while f: #这里只限制f是因为奇数时要往右多走一步
                s = s.next
                f = f.next
                if f: f = f.next
            return s
        #反转链表
        def reverse(head):
            pre,cur = None,head
            while cur:
                tmp = cur.next
                cur.next = pre
                pre,cur = cur,tmp
            return pre
        right = reverse(findhalf(head))
        while right:
            if right.val == head.val:
                right,head = right.next,head.next
            else: return False
        return True
```

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213112920703.png" alt="image-20201213112920703" style="zoom:50%;" />

> **A:** 迭代的思想最后来源于160链表公共点，序列尾部相同的查找
```python
class Solution: #层序遍历生成路径进行对比
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        #层序遍历记录父节点
        if not root: return
        fathers = {root:None}
        queue = [root]
        while queue:
            node = queue.pop(0)
            if node.left:
                fathers[node.left] = node
                queue.append(node.left)
            if node.right:
                fathers[node.right] = node
                queue.append(node.right)
        l1,l2 = p,q
        while l1!=l2:
            l1 = fathers.get(l1) if l1 else q #或者写为fathers.get(l1,q)
            l2 = fathers.get(l2) if l2 else p #fathers.get(l2,p)
        return l1
#递归，如果左右子树都找到了那么就说明root是最近        
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        #p和q一定在公共祖先的左右子树上
        if not root: return 
        if root == p or root == q: return root
        # 去左子树和右子树分别找
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        if left and right: return root
        if left: return left
        return right
```

#### [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201228120038315.png" alt="image-20201228120038315" style="zoom:50%;" />

> **A:** 两次遍历找到nums[i]左边所有数乘积和右边，然后L[i]*R[i]即可
```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        L,R,output = [1 for i in range(n)],[1 for i in range(n)],[1 for j in range(n)]
        for x in range(1,n):
            L[x] = L[x-1] * nums[x-1]
        for y in range(n-2,-1,-1):
            R[y] = R[y+1] * nums[y+1]
        for j in range(n):
            output[j] = L[j]*R[j]
        return output
#优化到O1空间复杂度
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        output = [1 for i in range(n)]
        for i in range(1,n):
            output[i] = output[i-1] * nums[i-1] #左边所有数的乘积
        R = 1 #用于累积右边所有数乘积
        for j in range(n-1,-1,-1):
            output[j] *= R #乘以右边所有数
            R *= nums[j] #更新R
        return output
```

#### [[滑动窗口]-*239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

> **Q:**



> **A:** 找固定区间内的最值，第一时间想到分桶法，见官方解法3；用双向队列做了出来，思路是：l和r控制窗口大小，维护一个单调递减的双向队列，因为一旦有新的更大的元素入队（说明这个元素满足滑动窗口长度），之前的比它小的都没用了（肯定在一个区间内），以此类推，当r和l的距离达到k时最大值即为队首元素。
```python
#最大堆的方法
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        # 注意 Python 默认的优先队列是小根堆
        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)

        ans = [-q[0][0]]
        for i in range(k, n):
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] <= i - k:
                heapq.heappop(q)
            ans.append(-q[0][0])
        
        return ans
#双向队列
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        queue,output = [],[]
        l = r = 0
        while r < n:
            while queue and nums[queue[-1]] <= nums[r]:
                queue.pop()
            queue.append(r)
            if r-l == k-1:
                while queue[0] < l: queue.pop(0)
                output.append(nums[queue[0]])
                l += 1
            r += 1     
        return output
```

#### [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201230153412893.png" alt="image-20201230153412893" style="zoom:50%;" />

> **A:** 可以按照对角线进行对行和列的二分搜索，复杂度O(logn!)；或者找左下角和右上角，然后比较更新i,j即可
```python
class Solution:
    def searchMatrix(self, matrix, target):
        #找左下角和右上角，左上角和右下角不行，是min和max
        
        #选左上角，往右走和往下走都增大，不能选

        #选右下角，往上走和往左走都减小，不能选

        #选左下角，往右走增大，往上走减小，可选

        #选右上角，往下走增大，往左走减小，可选
        if not matrix: return False
        m, n = len(matrix), len(matrix[0])
        i, j = m-1, 0
        while i >= 0 and j < n:
            if target > matrix[i][j]: j += 1
            elif target < matrix[i][j]: i -= 1
            else: return True
        return False
```

#### [[动态规划]-279*. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201229143126100.png" alt="image-20201229143126100" style="zoom:50%;" />

> **A:** 动态规划，dp[i]找之前所有dp[j]的最小个数，记得保存下平方和的数组，不用每次都计算了；更优化的方法是完全背包问题，每个数x的价值为1，重量为x**2，找到恰好把背包装满的价值最小的方法
```python
class Solution:
    def numSquares(self, n: int) -> int:
        if n <= 2: return n
        square_nums = [i**2 for i in range(0, int(math.sqrt(n))+2)]
        dp = [float('inf') for i in range(n+1)]
        dp[0],dp[1] = 0,1
        for i in range(2,n+1):
            k = 1
            while square_nums[k] <= i:
                dp[i] = min(dp[i],dp[i-square_nums[k]]+1)
                k += 1
        return dp[-1]
#完全背包
class Solution:
    def numSquares(self, n: int) -> int:
        m = int(n**0.5)
        dp = list(range(n+1))
        for i in range(1, m):
            cur = (i + 1) ** 2
            for j in range(cur, n+1):
                dp[j] = min(dp[j], dp[j-cur] + 1)
        return dp[-1]
```

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201229142856221.png" alt="image-20201229142856221" style="zoom:50%;" />

> **A:** 两种思路，一种是遍历然后遇到的第j个非零数就和j位置上的元素交换；第二种是双指针，l找0，r找l后面的非零，然后交换
```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        l = r = 0
        while l < n-1:
            while l < n-1 and nums[l] != 0: l += 1
            r = max(r,l)
            while r < n-1 and nums[r] == 0: r += 1
            nums[l],nums[r] = nums[r],nums[l]
            l += 1

    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        j = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[j] , nums[i]= nums[i] , nums[j]
                j += 1
```

#### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201229140541160.png" alt="image-20201229140541160" style="zoom:50%;" />

> **A:** 类似141，142环形链表，名字叫Floyd 判圈算法，当链表中存在环，快慢指针相遇的地方重新令n=0，n和s再次相遇就是环入口
```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        #快慢指针
        f = s = 0 #重复数字的地方会形成环
        while s == 0 or f != s:
            f = nums[nums[f]]
            s = nums[s]
        n = 0
        while n != s:
            s = nums[s]
            n = nums[n]
        return s
```

#### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213143410812.png" alt="image-20201213143410812" style="zoom:50%;" />

> **A:** 层序遍历编码，之后再层序遍历解码
```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root: return 
        queue = [root]
        output = []
        while queue:
            node = queue.pop(0)
            if node:
                output.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
            else:
                output.append('None')
        return '[' + ','.join(output) + ']'
        

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data: return 
        nodes = data[1:-1].split(',')
        index = 1
        root = TreeNode(int(nodes[0]))
        queue = [root]
        while queue:
            node = queue.pop(0)
            if nodes[index] != 'None':
                node.left = TreeNode(int(nodes[index]))
                queue.append(node.left)
            index += 1
            if nodes[index] != 'None':
                node.right = TreeNode(int(nodes[index]))
                queue.append(node.right)  
            index += 1
        return root     
```

#### [[动态规划]-300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213171048192.png" alt="image-20201213171048192" style="zoom:50%;" />

> **A:** [答案分析](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/yi-bu-yi-bu-tui-dao-chu-guan-fang-zui-you-jie-fa-x/)，将问题转化为维护一个数组，然后可以利用二分法（也可以不用二分法暴力求解都行），但是要理解如何转化的；同样的问题还有[646. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)，也可以利用维护一个最佳数组解出来 p.s.:用DP也可以做，但是复杂度是ON2
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        #维护一个虚拟递增数组，新进来的找位置即可
        n = len(nums)
        tmp = [nums[0]]
        for i in range(1,n):
            index = self.bi_search(tmp,nums[i])
            if index >= len(tmp): tmp.append(nums[i])
            else: tmp[index] = nums[i]
        return len(tmp)
	# 通用二分查找
    def bi_search(self,tmp,target):
        l,r = 0,len(tmp)-1
        while l <= r:
            mid = l + (r-l) // 2
            if tmp[mid] < target:
                l = mid+1
            elif tmp[mid] > target:
                r = mid-1
            else: return mid
        return l

    
#DP硬做
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1 for i in range(n)] #dp[i]表示前i+1的最长子序列
        for i in range(1,n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i],dp[j]+1)
        return max(dp)
```

#### [[完全背包]-322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215143513776.png" alt="image-20201215143513776" style="zoom:50%;" />

> **A:** 第一种方法是最朴素的想法（这种一定要掌握，记得初始化要对，第一行全是0，第一列全是inf想象成0个硬币去拟合k需要无穷个），第二个是完全背包问题的解答（即第一种方法中`f[i][j]`只和上一层一个状态 (`f[i-1]f[j]`) 和这一层的一个状态 `(f[i][j-c]+1)` 有关。可以将状态优化为**一维数组**），见[这里](https://leetcode-cn.com/problems/coin-change/solution/yong-bei-bao-wen-ti-si-xiang-lai-li-jie-ying-bi-zh/)，思想不同于01背包，即第k轮更新后面的时候需要前面已经更新好了，故正序
```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if not coins: return -1
        n = len(coins)
        dp = [[float('inf') for i in range(amount+1)] for j in range(n+1)]
        #dp[0][0]代表没有硬币组成0需要0个硬币，dp[0]代表没有硬币组成k需要无穷个，dp[i][0]代表i个硬币组成0需要0
        for i in range(n+1): dp[i][0] = 0
        for i in range(1,n+1):
            for j in range(1,amount+1):
                if j < coins[i-1]: dp[i][j] = dp[i-1][j]
                else: dp[i][j] = min(dp[i-1][j],dp[i][j-coins[i-1]]+1)
        return dp[-1][-1] if dp[-1][-1] < float('inf') else -1
    
class Solution: #第一种方法的1D优化版
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf') for i in range(amount+1)]
        dp[0] = 0
        for coin in coins:
            for j in range(coin,amount+1):
                dp[j] = min(dp[j],dp[j-coin]+1)
        return dp[-1] if dp[-1] < float('inf') else -1
```

#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209205439079.png" alt="image-20201209205439079" style="zoom:50%;" />

> **A:** 类似124，543和687，迭代过程中更新max但返回值不同；可以不用self.p，因为根肯定是最大的值；动态规划的方法以后可以学
```python
class Solution:
    def rob(self, root: TreeNode) -> int:
        # 分为偷根和不偷根
        def dfs(root):
            if not root: return 0,0
            tl,nl = dfs(root.left)
            tr,nr = dfs(root.right)
            #当前节点偷
            t = root.val + nl + nr
            #当前节点不偷
            nt = max(tl,nl)+max(tr,nr)
            return t,nt
        return max(dfs(root))
```

#### [[位运算]-338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215140236457.png" alt="image-20201215140236457" style="zoom:50%;" />

> **A:** 可以采取从0-num的191的挨个计算，我是找规律做的
```python
class Solution:
    def countBits(self, num: int) -> List[int]:
        if num == 0: return [0]
        import math
        k = int(math.log2(num))+1
        output = [0,1]
        for i in range(k-1):
            output += [x+1 for x in output] #找规律从0,1开始，后面的是前面的+1
        return output[:num+1]
```

#### [[堆栈]-394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210101165136330.png" alt="image-20210101165136330" style="zoom:50%;" />

> **A:** 堆栈思想，分情况判断
```python
#https://blog.csdn.net/lssrain/article/details/88825776 判断字符串为字母or数字
class Solution:
    def decodeString(self, s: str) -> str:
        n = len(s)
        kf,kc,count = [],[],-1 #kf存储字符串重复的次数，kc存储重复字符串的内容，count用来统计次数（防止'100'这样）
        output = ''
        for i in range(n):
            if not kf and s[i].isalpha(): #如果kf空则说明此时没有在[]内，直接放入output
                output += s[i]
            elif s[i].isdigit(): #如果是数字，就要统计出次数（连续数字100这样）
                if count == -1: count = s[i]
                else: count += s[i]
            elif s[i] == '[': #左括号，需要把count变成倍数并push进入kf，同时count复原，kc加入空列表
                kf.append(int(count))
                count = -1
                kc.append([])
            elif s[i] == ']': #右括号，看看kf是否空，空了说明直接加入output，非空加入kc的最后一个中，仍有嵌套
                content = kc.pop() * kf.pop()
                if not kf: output += ''.join(content)
                else: kc[-1] += content
            else: #单纯的字母直接加入kc最后一个
                kc[-1].append(s[i])
        return output
```
#### [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210101174646283.png" alt="image-20210101174646283" style="zoom:50%;" />

> **A:** 两种方法：1.递归，找到0的最小身高k，必在第一个位置，之后所有比k矮的-1继续递归即可，记得1加回来；2. 按身高逆序，前人数升序，然后直接一个fo循环即可
```python
class Solution: #递归
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        n = len(people)
        if n < 2: return people
        mint,pop = float('inf'),0
        for i in range(n):
            if people[i][1] == 0 and mint > people[i][0]:
                mint = people[i][0]
                k = i
        people.pop(k)
        for j in range(n-1):
            if people[j][0] <= mint: people[j][1] -= 1
        new = self.reconstructQueue(people)
        for j in range(n-1):
            if new[j][0] <= mint: new[j][1] += 1        
        return [[mint,0]]+new

class Solution: #排序
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        n = len(people)
        people = sorted(people,key = lambda x:(-x[0],x[1]))
        new = []
        for i in range(n):
            k = people[i][1]
            if k != i:
                new.insert(k,people[i])
            else: new.append(people[i])
        return new
```

#### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209174432896.png" alt="image-20201209174432896" style="zoom:50%;" />

> **A:** 和112路经总和原理类似，可以在那个的基础上递归做，也可以采用层序遍历的方法
```python
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> int:
        #BFS层序遍历带东西，前序遍历也可以
        if not root: return 0
        queue,res = [(root,[root.val])],0
        while queue:
            node,arr = queue.pop(0)
            res += arr.count(sum)
            arr.append(0)
            if node.left:
                temp = [x+node.left.val for x in arr]
                queue.append((node.left,temp))
            if node.right:
                temp = [x+node.right.val for x in arr]
                queue.append((node.right,temp))
        return res
#DFS递归做，记录累计和即可，每加入一个新元素就更新所有的和
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        def dfs(root,sumlist):
            count = 0
            if not root: return count
            sumlist = [num+root.val for num in sumlist]
            sumlist.append(root.val)
            return sumlist.count(targetSum) + dfs(root.left,sumlist) + dfs(root.right,sumlist)
        return dfs(root,[])
```

#### [[滑动窗口]-438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210101180356064.png" alt="image-20210101180356064" style="zoom:50%;" />

> **A:** 类似76最小覆盖子串，简化版，一起复习
```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        res = []
        if len(p) > len(s):     
            return res
        dic = {}
        m = len(p)
        count = m
        for i in range(m):
            dic[p[i]] = dic.get(p[i], 0) +1   #记录所需元素及个数
        i = 0
        while i < len(s):
            if s[i] in dic:              
                dic[s[i]] -= 1               #如果S[i]在dic中存在，更新值
                if dic[s[i]] >= 0:           #如果dic[s[i]]<0,表明不需要这个数，不能更新count
                    count -= 1
            if i >= m:                       # 当i>=m, 弹出失效的字符，保证长度相等
                if s[i-m] in dic:
                    dic[s[i-m]] += 1        #s[i-m]未必一定在dic中，需要判断
                    if dic[s[i-m]] > 0:     #需要的数被弹出，更新count
                        count += 1
            if count == 0:
                res.append(i-m+1)
            i += 1
        return res
#图省事儿版和76一致思路    
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        letters = {}
        for i in p:
            letters[i] = letters.get(i,0) + 1
        l,r = 0,0
        n = len(s)
        output = []
        tmp = letters.copy()
        while r < n:
            if s[r] in tmp:
                tmp[s[r]] -= 1
                if tmp[s[r]] == 0:
                    tmp.pop(s[r])
                r += 1
                if not tmp:
                    output.append(l)
                    tmp[s[l]] = 1
                    l += 1
            else:
                l,r = l+1,l+1 #图省事儿了
                tmp = letters.copy()
        return output
```

#### [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201216141031380.png" alt="image-20201216141031380" style="zoom:50%;" />

> **A:** 脑筋急转弯，第一次遍历把|nums[i]|-1位置的数变成负数，第二次遍历只需要找不是负的index就行了
```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums)
        output = []
        for i in range(n):
            index = abs(nums[i])-1
            if nums[index] > 0: nums[index] *= -1
        for j in range(n):
            if nums[j] > 0: output.append(j+1)
        return output
```

#### [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210101182059476.png" alt="image-20210101182059476" style="zoom:50%;" />

> **A:** 通过异或运算先找到所有不同，然后利用191布赖恩·克尼根算法计算位数
```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        nt = x^y #找到不同
        output = 0 #191布赖恩·克尼根算法计算位数
        while nt != 0:
            nt &= nt-1
            output += 1
        return output
```

#### [[背包问题]-494. 目标和](https://leetcode-cn.com/problems/target-sum/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215141443346.png" alt="image-20201215141443346" style="zoom:50%;" />

> **A:** 思路同416背包问题，将问题转化为从数列中找到和为num的子列，这个题是求数量；P.S.:注意判断S>数组和的情况，不然超时
```python
class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -> int:
        #同样转化为目标和
        if not nums: return 0
        s,n = sum(nums),len(nums)
        if (s+S)%2 == 1 or S > s: return 0
        target = (s+S)//2
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        #01背包问题模板
        for i in range(n):
            for j in range(target,nums[i]-1,-1):
                dp[j] += dp[j-nums[i]]
        return dp[-1]
```

#### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213155534005.png" alt="image-20201213155534005" style="zoom:50%;" />

> **A:** 二叉搜索树的中序遍历有序，逆中序遍历为倒序（右-根-左），不断累加bigger和node.val相加即可
```python
class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        #利用中序遍历有序，两次遍历似乎可以，或者一次进行逆序中序遍历
        stack = []
        cumsum = 0
        node = root
        while stack or node:
            while node:
                stack.append(node)
                node = node.right
            node = stack.pop()
            node.val += cumsum
            cumsum = node.val #更新cumsum累计值
            node = node.left
        return root
```

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

> **Q:**

![image-20201209143206148](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209143206148.png)

> **A:** 递归求左右子树的高度并更新output；树的直径就等于某个根节点的左右子树的高度和。类似124，543和687，迭代过程中更新max但返回值不同

```python
class Solution:
    def __init__(self):
        self.output = 0
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        if not root: return self.output
        def depth(root):
            if not root: return 0
            left = depth(root.left)
            right = depth(root.right)
            self.output = max(self.output,left+right)  #left,right是节点个数，直径=节点数-1，故不用算root
            return max(left,right) + 1
        depth(root)
        return self.output
```

#### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210102154340607.png" alt="image-20210102154340607" style="zoom:50%;" />

> **A:** j-i的连续子序列和可以表示为[0,i]-[0,j-1]，故我们只需要收集0-n-1的所有子序列和，之后做差即可，用hashmap可以优化，key是和的值，value是取该和的子序列个数

```python
class Solution:
    def subarraySum(self, nums, k):
        dic = {}
        dic[0] = 1
        total = count = 0
        for i in range(len(nums)):
            total += nums[i]
            if total - k in dic:
                count += dic[total - k]
            dic[total] = dic.get(total, 0) + 1
        return count
```

#### [572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209180411271.png" alt="image-20201209180411271" style="zoom:50%;" />

> **A:** 一棵子树上的点在 DFS 序列（即先序遍历）中是连续的，但是要注意空子树用*代替，每条子树开头+#以防[12]和[2]这样的树

```python
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        ss = self.preorder(s)
        st = self.preorder(t)
        print(st,ss)
        return st in ss
        
    def preorder(self,root):
        stack,output = [root],""
        while stack:
            node = stack.pop()
            if node: 
                output += '#'+str(node.val)
                stack.append(node.right)
                stack.append(node.left)
            else: output += '*'

        return output
#递归的方法，内部递归函数鉴定两棵树是否一致，灵感来源于剑指26
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:

        if not s: return False

        def recur(p1,p2):
            if not p1 and not p2: return True
            if not p1 or not p2: return False
            if p1.val != p2.val: return False
            else: return recur(p1.left,p2.left) and recur(p1.right,p2.right)
        
        return recur(s,t) or self.isSubtree(s.left,t) or self.isSubtree(s.right,t)
```

#### [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210102163540289.png" alt="image-20210102163540289" style="zoom:50%;" />

> **A:** 1. 排序后比较第一个和最后一个位置不对的left和right 2. 找到**最短子序列中**最小值和最大值需要安放的地方即可
```python
class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        sort_nums = sorted(nums)
        left = 0
        right = len(nums) - 1
        while left <= right and nums[left] == sort_nums[left]:
            left += 1
        while left <= right and nums[right] == sort_nums[right]:
            right -= 1
        return right - left + 1
    	#复杂度为O(N)的方法
        #分三段，ABC，A中的所有元素i小于i后续元素的最小值，C中则大于
        #故问题转化为找i右边的最小值，和i左边的最大值，同42接雨水
        n = len(nums)
        ldp = [float('-inf') for _ in range(n)]
        rdp = [float('inf') for _ in range(n)]
        for i in range(1,n):
            ldp[i] = max(ldp[i-1],nums[i-1])
        for j in range(n-2,-1,-1):
            rdp[j] = min(rdp[j+1],nums[j+1])
        l,r = 0,n-1
        while l <= n-1 and nums[l] <= rdp[l]:
            l += 1
        while r >= 0 and nums[r] >= ldp[r]:
            r -= 1
        #print(l,r,ldp,rdp)
        return r-l+1 if r >= l else 0
```

#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209154239131.png" alt="image-20201209154239131" style="zoom:50%;" />

> **A:** 递归的方法都可以用层序遍历做
```python
class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
        if not t1: return t2
        if not t2: return t1
        t1.val = t1.val + t2.val
        t1.left = self.mergeTrees(t1.left,t2.left)
        t1.right = self.mergeTrees(t1.right,t2.right)
        return t1
```

#### [[动态规划]-647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210102165555536.png" alt="image-20210102165555536" style="zoom:50%;" />

> **A:** 思路同5最长回文子串，记录个数即可，动态规划
```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        #同最长回文子串，DP[i][j]表示长度为i+1的从j开始的是否为回文子串
        n = len(s)
        dp = [[False]*n for _ in range(n+1)]
        dp[0] = dp[1] = [True]*n
        r = n
        for i in range(2,n+1):
            for j in range(n-i+1):
                if s[j] == s[j+i-1] and dp[i-2][j+1]:
                    dp[i][j] = True
                    r += 1
        return r
```

#### [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

> **Q:**

![image-20201209203844677](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209203844677.png)

> **A:** 类似124和543两道题目，递归的过程中更新max但是递归返回值不同于max，思考见[github](https://github.com/zjuzhfbloodz/LeetCode/blob/master/leetcode-algorithms/687.%20Longest%20Univalue%20Path/0687.md)很清楚
```python
class Solution:
    def longestUnivaluePath(self, root: TreeNode) -> int:
        self.p = 0
        
        def inner(root):
            if not root: return 0
            if not root.left and not root.right: return 1
            ml,mr = 0,0 #ml和mr是为了后面判断更方便，即ml>0说明左子树和根相等，否则说明不等
            left = inner(root.left)
            right = inner(root.right)
            if root.left and root.left.val == root.val:
                ml += left
            if root.right and root.right.val == root.val:
                mr += right
            self.p = max(self.p,ml+mr)
            if ml > 0 and mr > 0: return max(ml,mr)+1
            else: return ml+mr+1

        inner(root)
        return self.p
```

#### [[单调栈]-739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

经典单调栈题目

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        #维护一个单调递减的栈
        n = len(temperatures)
        stack = []
        output = [0 for _ in range(n)]
        for i in range(n):
            while stack and temperatures[stack[-1]] < temperatures[i]:
                index = stack.pop()
                output[index] = i-index
            stack.append(i)
        return output
```



#### [[哈希]-771. 宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210102170218865.png" alt="image-20210102170218865" style="zoom:50%;" />

> **A:** Hashmap两次遍历即可
```python
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        dic,output = {},0
        for s in stones:
            if dic.get(s): dic[s] += 1
            else: dic[s] = 1
        for j in jewels:
            output += dic.get(j,0)
        return output
```

#### [[动态规划]-1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222153914181.png" alt="image-20201222153914181" style="zoom:50%;" />

> **A:** 动态规划，如果text1[i] == text2[j]，则DP要更新，否则选最大的；[583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)，思路一致，求得公共子串后即得
```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        #DP[i][j]表示text1的前i个字符和text2的前j个字符的最长子序列长度
        m,n = len(text1),len(text2)
        dp = [[0]*(n+1) for i in range(m+1)]
        for i in range(1,m+1):
            for j in range(1,n+1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])
        return dp[-1][-1]
```