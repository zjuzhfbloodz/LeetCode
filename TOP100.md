[TOC]

### 一些思想

#### 1. 动态规划问题

- 搞清楚或记牢DP代表的含义，之后对应的转移方程其实迎刃而解了
- 如果每次更新只用到i-1或者2D用到i-1和i的，那么要想到可以优化空间复杂度

> 包含问题：5-10-39-42-53-55-62-96-152-221-279-300-647-1143共14题


#### 2. 背包问题通解

- 完全背包问题，按先硬币后数值的双循环**正序**更新1D的dp

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        for c in candidates: #先硬币
            for i in range(c,target+1): #后数值
                dp[i] += dp[i-c]
        return dp[-1]
```

- 01背包问题，按先硬币后数值的双循环**逆序**更新1D的dp，2D版本复习见494题解
```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        for c in candidates: #先硬币
            for i in range(target,c-1,-1): #后逆序数值
                dp[i] += dp[i-c]
        return dp[-1]
```
#### 3. 链表问题，针对边界值的特殊情况，加一个dummy会好很多
> 包含问题：19-
#### 4. Python基础操作

- 堆[heapq](https://www.jianshu.com/p/801318c77ab5)

```python
import heapq
heap = heapq.heappush(heap,value) #添加元素
heap = heapq.heappop(heap) #pop最小值，最大堆可以全加负号
#创建heap
#第一种
nums = [2, 3, 5, 1, 54, 23, 132]
heap = []
for num in nums:
    heapq.heappush(heap, num)  # 加入堆

print(heap[0])  # 如果只是想获取最小值而不是弹出，使用heap[0]
print([heapq.heappop(heap) for _ in range(len(nums))])  # 堆排序结果
# out: [1, 2, 3, 5, 23, 54, 132]

# 第二种
nums = [2, 3, 5, 1, 54, 23, 132]
heapq.heapify(nums)
print([heapq.heappop(nums) for _ in range(len(nums))])  # 堆排序结果
# out: [1, 2, 3, 5, 23, 54, 132]
```

- 集合set+列表list+字典

```python
a,b = set(),[1,2,3]
a.add(1) #新增
a.remove(1) #删除元素，不要用pop，是随机的
1 in a == True
b.index(1) == 0
b.remove(1) #删除值为1的元素
#生成字典的方式，字典只有pop没有remove
for i in p:
    letters[i] = letters.get(i,0) + 1
```

- 队列[deque](https://www.cnblogs.com/ranzhong/p/12438841.html)

```python
#python3目前不用import包
掌握append,pop,popleft即可，还可以extend([1,2,3])
```

- [运算符](https://www.runoob.com/python/python-operators.html)

```python
a = 0011 1100

b = 0000 1101

-----------------

a&b = 0000 1100 #与运算，双1为1

a|b = 0011 1101 #或运算，有1就为1

a^b = 0011 0001 #异或运算，a和b不同为1

~a  = 1100 0011 #0-1，1-0
```

- 注意事项：传递列表的时候要加list[:]，不然list改变之后，之前所有的list都会变
- 字符串

```python
s = "3[a]2[bc]"
s[0].isdigit() #True，判断数字
s[2].isalpha() #True，判断字母
s[0].isalpha() #False
```

- 排序，sorted(list)，key是排序的依据，可以改写为函数见[这里](https://blog.csdn.net/u013383813/article/details/82775211)和题目179最大数



#### 5. 滑动窗口

思想：用双指针i,j表示滑动窗口的左边界和右边界，通过改变i,j来扩展和收缩滑动窗口，可以想象成一个窗口在字符串/数组上游走，当这个窗口包含的元素满足题目条件时，记录下当前状态，之后继续更新i和j找到新的满足状态。

```python
l = 0
for r in range(n): #当然也可以用while r < n，r从0开始
    if 不满足条件：
    	output更新
        l更新
    r更新
    条件更新
```





#### 6. 单调栈

如下代码是739每日温度的解答，是一个标准的单调栈，类似的问题还有42接雨水，84/85最大面积矩形

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        #维护一个单调递减的栈
        n = len(temperatures)
        stack = []
        output = [0 for _ in range(n)]
        for i in range(n):
            while stack and temperatures[stack[-1]] < temperatures[i]:
                index = stack.pop()
                output[index] = i-index
            stack.append(i)
        return output
```



#### 7. 二分查找

经典题目[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)，找的是找到大于等于target的第一个位置

- 以下代码中给到两种方法，对于一定存在于数组中的数，用第二种方法

![image-20210819222823467](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210819222823467.png)

```python
#精确查找，如果找>=target的第一个位置，则output==l，否则output==r
def bi_search(seq,target):
    if not seq: return
    n = len(seq)
    l,r = 0,n-1
    while l <= r:
        mid = l + (r-l)//2
        if seq[mid] > target:
            r = mid - 1
        elif seq[mid] < target:
            l = mid + 1
        else:
            return mid
    return -1
#两种方案，这是另一种
	def bi_search(nums,target): #难道说是，对于查找一定存在的数就用这个方法？
        #找到大于等于target的第一个位置
        if not nums: return
        n = len(nums)
        l,r = 0,n-1
        while l < r:
            mid = l + (r-l)//2
            if nums[mid] > target:
                r = mid
            elif nums[mid] < target:
                l = mid + 1
            else:
                return mid
        return r if r != n-1 or nums[r] >= target else r+1
```

#### 8. 题目考察网站

https://codetop.cc/#/home

#### 9. 数据流问题

- 数据流选TOP K：堆排序，小顶堆
- 数据流随机抽样，[蓄水池算法](https://blog.csdn.net/dm_ustc/article/details/45875971)

- 数据流中位数：建立一个大顶锥，一个小顶锥，大顶锥的元素要小于小顶锥且大顶锥和小顶锥元素不能差超过1

### 题目

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

> **Q:** HashMap

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201022220130608.png" alt="image-20201022220130608" style="zoom:50%;" />

> **A:** 可以用字典加速达到O(N)，继续优化就是一边更新字典一边选，选到了直接output
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hash = {}
        n = len(nums)
        for i in range(n):
            if nums[i] in hash: #找到了就output
                return [hash[nums[i]],i]
            else: #没找到加入字典继续
                hash[target-nums[i]] = i
```


#### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

> **Q:** Linked List

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201022222353644.png" alt="image-20201022222353644" style="zoom:50%;" />

> **A:** 同样用dummy作为头部，只要l1或l2或extra(余数)还存在就继续加
```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1: return l2
        if not l2: return l1
        extra = 0
        dummy = ListNode()
        node = dummy
        while l1 or l2 or extra==1:  #extra是余数，只要还有l1l2或r就要继续增加节点
            value = extra
            if l1: 
                value += l1.val
                l1 = l1.next
            if l2: 
                value += l2.val
                l2 = l2.next
            value,extra = value % 10,value // 10      
            node.next = ListNode(val=value)
            node = node.next
        return dummy.next
```


#### [[滑动窗口]-3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

> **Q:** Dual Pointer

![text](https://github.com/zjuzhfbloodz/LeetCode/raw/master/questions/0003.png?raw=true)

> **A:** 双指针模拟滑动窗口；我用的字典记录字符和位置，遇到相同的直接将位置之前的所有都pop即可（更快）
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        #思路是双指针，或者叫滑动窗口
        i,j,maxlen = 0,0,0

        while j < len(s): #后面的指针不能超过s长度
            if s[j] not in s[i:j]: #没重复，j向后
                j += 1
            else:
                maxlen = max(maxlen,j-i)   #重复了，更新最值，i向后，直到没有重复之前j不变
                i += 1     
                #i += s[i:j].find(s[j]) + 1  #没有提升多少，迅速更新最新i到和j重复的字符之后
                 
        return max(maxlen,j-i) #防止全不同的序列没有更新过
#优化方法   
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        #滑动窗口，可以用hashmap存储
        hashmap = {}
        n = len(s)
        l = 0
        output = 0
        for i in range(n):
            if s[i] in hashmap:
                output = max(output,i-l)
                r = hashmap[s[i]]
                for j in range(l,r+1):
                    hashmap.pop(s[j])
                l = r+1
            hashmap[s[i]] = i
        return max(output,len(hashmap)) #防止全是不重复的不更新output
```

#### [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

> **Q:** Recursion

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201023183841426.png" alt="image-20201023183841426" style="zoom:50%;" />

> **A:** 本质上是两个有序数组中找第k小的数。把k拆为k//2然后比较两个数组对应位置的数，小的那个前k//2都不可能为第k小的数
```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        #技巧使代码更统一精简，如果两个数组长度和是奇数，那么k1=k2，计算均值同偶数形式不用改写了
        n1,n2 = len(nums1),len(nums2)
        k1 = (n1+n2+1) // 2
        k2 = (n1+n2+2) // 2
        #本质上是两个有序数组中找第k小的数
        def inner(l1,l2,k):
            
            if len(l1) < len(l2): l1,l2 = l2,l1#保持nums1比较长
            if len(l2) == 0: return l1[k-1] #即当nums2走到尽头的时候，直接返回
            if k == 1: return min(l1[0],l2[0]) #找最小数，比较数组首位
            t = min(k//2,len(l2)) # t每次是要找的位数的1/2，这样使复杂度达到log，且保证不上溢
            if l1[t-1] >= l2[t-1]: return inner(l1,l2[t:],k-t) #这里是t意味前k//2个都不能要
            else: return inner(l1[t:],l2,k-t)

        return (inner(nums1,nums2,k1)+inner(nums1,nums2,k2)) / 2
#自己完成的方法
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        n1,n2 = len(nums1),len(nums2)
        k = (n1+n2) // 2
        def findk(nums1,nums2,k):
            if not nums1: return nums2[k-1]
            if not nums2: return nums1[k-1]
            if k == 1: return min(nums1[0],nums2[0])
            t1 = min(k//2,len(nums1)) - 1
            t2 = min(k//2,len(nums2)) - 1
            if nums1[t1] < nums2[t2]:
                return findk(nums1[t1+1:],nums2,k-t1-1)
            else:
                return findk(nums1,nums2[t2+1:],k-t2-1)
        if (n1+n2)%2 == 1: return findk(nums1,nums2,k+1)
        return (findk(nums1,nums2,k) + findk(nums1,nums2,k+1))/2
```

#### [[动态规划]-5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

> **Q:** Dynamic Programming

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201024173612969.png" alt="image-20201024173612969" style="zoom:50%;" />

> **A:** 按回文串的长度x进行逐步DP动态规划，长度为3的依靠长度为1的，长度为5的依靠长度为3的，依次类推；类似题目647
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        #动态规划DP[i][j]表示从s[j]开始的长度为i的是否为回文
        if not s: return ''
        n = len(s)
        dp = [[False]*n for _ in range(n+1)]
        dp[0] = dp[1] = [True]*n
        output = s[0]
        for i in range(2,n+1):
            for j in range(n-i+1):
                if s[j] == s[j+i-1] and dp[i-2][j+1]:
                    dp[i][j] = True
                    output = s[j:j+i]
        return output
```

#### [[动态规划]-10*. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

> **Q:** Dynamic Programming

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201025214110071.png" alt="image-20201025214110071" style="zoom:50%;" />

> **A:** DP动态规划，分p中的字符种类三种情况"x * ."思考转移方程，[解答](https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-by-leetcode-solution/)
```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        #match函数用来判断两个字符是否匹配
        def match(i,j):
            if i == 0: return False #当s为空时，显然p[j-1]不能匹配，不用考虑诸如a*的情况，都在dp中包含了
            if p[j-1] == '.': return True
            return s[i-1] == p[j-1]
        #DP[i][j]表示s的前i个字符和p的前j个字符是否匹配
        m,n = len(s),len(p)
        dp = [[False]*(n+1) for i in range(m+1)]
        dp[0][0] = True
        for i in range(m+1):
            for j in range(1,n+1):
                if p[j-1] == '*': #如果为*有两种情况，抛去前两个和i匹配，或者如果相等就和i-1继续匹配
                    dp[i][j] = dp[i][j-2]
                    if match(i,j-1):
                        dp[i][j] = dp[i][j-2] or dp[i-1][j]
                else: #否则只能看是否相等
                    if match(i,j):
                        dp[i][j] = dp[i-1][j-1]
        return dp[-1][-1]

```

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

> **Q:** Dual Pointer

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201026150625433.png" alt="image-20201026150625433" style="zoom:50%;" />

> **A:** 头尾双指针，每次的area结果都是当前所有边中和短边构成面积的max，之后即可舍弃该短边，即短边索引+1或-1
```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # 对于每一个坐标i，他所能构成的area的max高度是自己的高度，max宽度一开始是len(height)-1
        # area = (r-l) * min(height[r],height[l])，依然是双指针
        l,r = 0,len(height)-1
        output = 0
        while l != r:
            if height[l] < height[r]:
                area = height[l] * (r-l)
                l += 1
            else:
                area = height[r] * (r-l)
                r -= 1
            output = max(output,area)
        return output
```

#### [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

用单指针扫描所有单词的所有字母即可，一旦有不同直接终止

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs or not strs[0]: return ""
        n = len(strs)
        index = 0
        flag = False
        while True:
            word = strs[0][index]
            for i in range(1,n):
                if index >= len(strs[i]) or strs[i][index] != word:
                    index -= 1
                    flag = True
                    break
            if flag or index+1 >= len(strs[0]): break
            index += 1
        return strs[0][:index+1]
```

#### [15*. 三数之和](https://leetcode-cn.com/problems/3sum/)

> **Q:** HashMap or Sort

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201027215546487.png" alt="image-20201027215546487" style="zoom:50%;" />

> **A:** 可以用hashmap类似第1题中的操作将复杂度降到O(N2)但判断更难，也可以使用排序的方法，更巧妙一些，**重点在于不要重复**
```python
#排序+双指针，很清楚，分first/second/third来做，固定first，则second和third为双指针
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums = sorted(nums)
        n = len(nums)
        output = []
        for first in range(n):
            if first > 0 and nums[first] == nums[first-1]: #此处要求不能重复
                continue
            third = n-1
            target = -1 * nums[first]
            for second in range(first+1,n):
                if second > first+1 and nums[second] == nums[second-1]: #同样不能重复
                    continue
                while third > second and nums[third]+nums[second] > target:
                    third -= 1
                if third == second: break
                if nums[third]+nums[second] == target:
                    output.append([nums[first],nums[second],nums[third]])
        return output
#hashmap类似题目1，先排序再做，遇到相同的元素直接continue，注意output中也不能有相同的元素
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        if n < 3: return []
        nums = sorted(nums)
        output = set()
        target = ''
        def twoSum(nums,target):
            m = len(nums)
            if n < 2: return
            hashmap = {}
            output = []
            for j in range(m):
                if nums[j] in hashmap:
                    output.append([nums[j],target-nums[j]])
                else:
                    hashmap[target-nums[j]] = j
            return output

        for i in range(n):
            if nums[i] == target: continue
            target = nums[i]
            result = twoSum(nums[i+1:],-1*target)
            for r in result:
                output.add((target,r[0],r[1]))
        return [list(i) for i in output]
```

#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

> **Q:** HashMap

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201028205544281.png" alt="image-20201028205544281" style="zoom:50%;" />

> **A:** 利用hashmap+回溯backtrack
```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: return []
        n = len(digits)
        dictionary = {'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}
        output = []
        r = []
        def traceback(index):
            if index == n:
                output.append(''.join(r))
                return
            word = dictionary[digits[index]]
            for w in word:
                r.append(w)
                traceback(index+1)
                r.pop()
        traceback(0)
        return output
```

#### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

> **Q:** Linked List

![image-20201029203546392](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201029203546392.png)

> **A:** 不用空节点的话，如果只有一个head且n=1没法执行，最后记得return dummy.next（也是为了特殊情况）
```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        #双指针，加一个空头不用判断特殊情况（即删除头节点的情况）
        dummy = ListNode(next=head)
        l = r = dummy
        for i in range(n+1): r = r.next
        while r:
            l,r = l.next,r.next
        l.next = l.next.next
        return dummy.next
```

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

> **Q:** Stack

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201109194515530.png" alt="image-20201109194515530" style="zoom:50%;" />

> **A:** 难度不大，使用stack先进后出即可
```python
class Solution:
    def isValid(self, s: str) -> bool:
        #先进后出stack，注意右括号是不能进入stack的，进入了就说明False
        n = len(s)
        stack = []
        r = {'[':']','{':'}','(':')'}
        for i in range(n):
            if s[i] in r:
                stack.append(s[i])
            else:
                if not stack or r[stack[-1]] != s[i]:
                    return False
                else:
                    stack.pop()
        #还剩元素说明肯定不匹配
        return True if not stack else False
```

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

> **Q:** Linked List and Dual Pointer

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201109195701797.png" alt="image-20201109195701797" style="zoom:50%;" />

> **A:** 依次比较大小生成新链表即可
```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        #双指针
        dummy = ListNode()
        head = dummy
        while l1 and l2:
            if l1.val >= l2.val:
                head.next = l2
                l2 = l2.next
            else:
                head.next = l1
                l1 = l1.next
            head = head.next
        if l1: head.next = l1
        if l2: head.next = l2

        return dummy.next
```

#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

> **Q:** STACK or Dynamic Programming

![image-20201112200640224](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201112200640224.png)

> **A1:** 回溯法。traceback([],left,right)，如果left>right则终止；之后如果left<n或right<n，则都可继续
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        output = []
        def traceback(r,left,right):
            if len(r) == 2*n:
                output.append(''.join(r))
                return
            if right > left: return
            if left < n:
                r.append('(')
                traceback(r,left+1,right)
                r.pop()
            if right < n:
                r.append(')')
                traceback(r,left,right+1)
                r.pop()
        traceback([],0,0)
        return output
```


#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

> **Q:** Heap or N Pointers

![image-20201204165107243](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201204165107243.png)

> **A:** 最小堆，复杂度nklog(k)，先将k个序列的第一个结点构成一个logk深度的最小堆，然后pop最小值，如果该节点还有next，将next入堆，继续做即可，每个节点入堆一次出堆一次（复杂度为log(k))，总计复杂度为nklog(k)
```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        import heapq
        n = len(lists)  
        heap = []
        for i in range(n):
            if lists[i]:
                heapq.heappush(heap,(lists[i].val,i))
                lists[i] = lists[i].next
        dummy = ListNode()
        node = dummy
        while heap:
            value,index = heapq.heappop(heap)
            node.next = ListNode(val=value)
            node = node.next
            if lists[index]:
                heapq.heappush(heap,(lists[index].val,index))
                lists[index] = lists[index].next
        return dummy.next
```

#### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

判断是否够k个+反转链表（有头有尾）+连接起来

- 思路：记录一个tail，这个tail是本次要翻转的子链的dummy，初始为dummy，tail的作用是连接已有的串和新翻转的子链

```python
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        dummy = ListNode(next=head)
        def reverse(head,tail):
            pre,cur = tail,head
            while cur != tail:
                tmp = cur.next
                cur.next = pre
                pre,cur = cur,tmp
            return pre
            
        node = dummy
        while node:
            tail = node 
            for i in range(k):
                node = node.next #尾巴
                if not node: 
                    return dummy.next
            new = reverse(tail.next,node.next) #tail.next就是子链反转之前的head，将成为新的tail
            node = tail.next
            tail.next = new

        return dummy.next
```



#### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

> **Q:** 

![image-20201205145502711](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201205145502711.png)

> **A:** 找到从右到左的第一个逆序数列，这个数列无法通过交换两个数的位置得到下一个字典序，故需要更新序列前面的数字即可
```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        index = n-1
        while index > 0 and nums[index] <= nums[index-1]: #找到从右到左的第一个逆序数列
            index -= 1
        nums[index:] = nums[index:][::-1] #将其逆转，并交换第一个大于前面数的序列中的数
        for i in range(index,n):
            if nums[i] > nums[index-1]:
                nums[index-1],nums[i] = nums[i],nums[index-1]
                break
```

#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

> **Q:**

![image-20201205173138334](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201205173138334.png)

> **A:** DP[i]表示前i个字符的括号个数，更新看i和i-1位置上的括号情况；栈的方法是匹配左右括号，多余的右括号起到了分割字符串的作用，即多余右括号之前的字符串都不能再算入了，问题的关键是右括号
```python
#动态规划
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        dp = [0 for i in range(n+1)]
        for i in range(2,n+1):
            if s[i-1] == ')':
                if s[i-2] == '(':
                    dp[i] = dp[i-2] + 2
                elif i-dp[i-1]-2 >= 0 and s[i-dp[i-1]-2] == '(':
                    dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2
        return max(dp)
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        #维护一个栈，栈底元素是最后一个未匹配的右括号的位置，用来分割字符串
        n = len(s)
        stack= [-1]
        output = 0
        for i in range(n):
            if s[i] == '(':
                stack.append(i)
            else:
                stack.pop()
                if stack:
                    output = max(output,i-stack[-1])
                else:
                    stack.append(i)
        return output 
```

#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

> **Q:** 二分搜索

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201207193822281.png" alt="image-20201207193822281" style="zoom:50%;" />

> **A:** 二分查找，一次遍历，每个mid划分出来一定有一段是完全升序的，分别比较即可
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # 多情况的二分查找，先判断mid在前半个升序子序列还是在后半个，之后再分情况讨论
        n = len(nums)
        l,r = 0,n-1
        while l <= r:
            mid = l+(r-l)//2
            if nums[mid] == target: return mid
            if nums[mid] >= nums[0]: #在前半个
                if target < nums[0] or target > nums[mid]:
                    l = mid+1
                else:
                    r = mid-1
            else: #在后半个
                if target > nums[-1] or target < nums[mid]:
                    r = mid-1
                else:
                    l = mid+1
        return -1
```

#### [[二分查找]-34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

二分查找，找target最左边的index，然后找target+1的最左边的index之后-1即可

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums: return [-1,-1]
        #二分找某个数最左边的位置
        def bi_search(nums,target):
            n = len(nums)
            l,r = 0,n-1
            while l <= r:
                mid = l+(r-l)//2
                if nums[mid] >= target:
                    r = mid-1
                else:
                    l = mid+1
            return l
        n = len(nums)
        left = bi_search(nums,target)
        if left >= n or nums[left] != target: return [-1,-1] #特殊情况判断，超过nums或者不在nums中
        right = bi_search(nums,target+1)
        return [left,right-1]
```



#### [[完全背包]-39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215173114825.png" alt="image-20201215173114825" style="zoom:50%;" />

> **A:** 完全背包问题，第一种方法是朴素思想，第二种是优化到1D
```python
class Solution:
    def combinationSum(self, candidates, target: int):
        #完全背包问题，dp[i][j]表示candidates[:j]能构成和为i的情况
        n = len(candidates)
        dp = [[[] for i in range(n+1)] for j in range(target+1)]
        for i in range(1,n+1):
            for j in range(1,target+1):
                dp[j][i] += dp[j][i-1] #无论j和当前硬币的大小，都要将之前的加上
                if j == candidates[i-1]: dp[j][i] += [[candidates[i-1]]]
                if j > candidates[i-1]:
                    dp[j][i] += [x+[candidates[i-1]] for x in dp[j-candidates[i-1]][i]]
        return dp[-1][-1]
    
class Solution: #优化到1D
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        dp = [[] for i in range(target+1)]
        dp[0] = [[]]
        for c in candidates:
            for i in range(c,target+1):
                for combine in dp[i-c]:
                    dp[i].append(combine+[c])
        return dp[-1]
    
#回溯法
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:

        n = len(candidates)
        output = []
        def traceback(r,index,target):
            if target < 0 or index > n: return
            if target == 0:
                output.append(r[:])
                return 
            for i in range(index,n):
                r.append(candidates[i])
                traceback(r,i,target-candidates[i]) #能用多次就是traceback(i)，否则就是+1
                r.pop()
        traceback([],0,target)
        return output
```

#### [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

长度为N的数组没出现的最小正整数一定在[1,N]之间，后续思路类似[448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        #长度为N的数组没出现的最小正整数一定在[1,N]之间
        n = len(nums)
        for i in range(n):
            if 1 <= nums[i] <= n:
                continue
            else:
                nums[i] = n+1
        for j in range(n):
            index = abs(nums[j])
            if 1 <= index <= n and nums[index-1] > 0:
                nums[index-1] = nums[index-1]*-1
        for x in range(n):
            if nums[x] > 0:
                return x+1
        return n+1
```



#### [[动态规划]-42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222120101668.png" alt="image-20201222120101668" style="zoom:50%;" />

> **A:** 要对每个height[i]找到0-(i-1)的max和(i+1)-(n-1)的max，这两个max中的min决定了height[i]所能接水的量，可以用DP来找；或者是用[巧方法](https://leetcode-cn.com/problems/trapping-rain-water/solution/wei-en-tu-jie-fa-zui-jian-dan-yi-dong-10xing-jie-j/)；DP可以优化到O1的空间复杂度，用双指针[见解答下面Lucien的评论](https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/)，即双指针指代左右两边的max，左边的max对于左边的index是可信的，右边同理，若左max小于右max，则左边index一定由左边决定，否则去看右边，类似84（84是两小夹一大，42是两大夹一小）
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 用两个DP分别记录下标i左边和右边的max，i所能存储的水量就是min(左,右)-height[i]
        n = len(height)
        ldp = [0 for i in range(n)]
        rdp = [0 for i in range(n)]
        output = 0
        for i in range(1,n): ldp[i] = max(ldp[i-1],height[i-1])
        for i in range(n-2,0,-1): 
            rdp[i] = max(rdp[i+1],height[i+1])
            r = min(ldp[i],rdp[i]) - height[i]
            if r > 0:
                output += r
        return output

    
class Solution:
    def trap(self, height: List[int]) -> int:
        #单调递减栈，新的大元素入栈说明和stack[-2]一起可以给stack[-1]位置的元素增加雨水（两大夹一小），如果只剩一个就直接pop
        n = len(height)
        stack = []
        output = 0
        for i in range(n):
            while stack and height[stack[-1]] < height[i]:
                h = height[stack.pop()]
                if stack: #如果stack为空，说明此时的h左边没有墙了，没办法接水
                    output += (min(height[stack[-1]],height[i])-h)*(i-stack[-1]-1)
            stack.append(i)
        return output
```

#### [[回溯]-46. 全排列](https://leetcode-cn.com/problems/permutations/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214140318038.png" alt="image-20201214140318038" style="zoom:50%;" />

> **A:** 前first-1个数字已经选好，后n-first如何选？就从后面依次和first位置交换（第一次自己和自己交换）即可；**注意选nums[:]，不然全是一样的**
```python
class Solution: #python的方法
    def permute(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        output = [[i] for i in nums]
        for i in range(n-1):
            output = [i+[j] for i in output for j in nums if j not in i] #if在后不需要else，在前必须else
        return output

class Solution: #回溯法
    def permute(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        output = []
        def traceback(index):
            if index == n:
                output.append(nums[:])
                return
            for i in range(index,n):
                nums[i],nums[index] = nums[index],nums[i]
                traceback(index+1)
                nums[i],nums[index] = nums[index],nums[i]
        traceback(0)
        return output
```

#### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215192601335.png" alt="image-20201215192601335" style="zoom:50%;" />

> **A:** 转置+倒序
```python
class Solution:
    def rotate(self, matrix):
        #转置+逆序
        m,n = len(matrix),len(matrix[0])
        for i in range(m):
            for j in range(i+1,n):
                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]
            matrix[i].reverse()
```

#### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215194030847.png" alt="image-20201215194030847" style="zoom:50%;" />

> **A:** 字母异位词的sorted(list)是相同的，从这点出发即可；另外，从list转到dict哈希表之后速度明显变快
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        hashmap = {}
        for s in strs:
            key = ''.join(sorted(s))
            if key in hashmap:
                hashmap[key].append(s)
            else:
                hashmap[key] = [s]
        return list(hashmap.values())
#(0,0,0,0,1,...,1,0)共26维向量，异位词的向量相同，转为tuple作为key
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        mp = {}

        for st in strs:
            counts = [0] * 26
            for ch in st:
                counts[ord(ch) - ord("a")] += 1
            # 需要将 list 转换成 tuple 才能进行哈希
            key = tuple(counts)
            mp[key] = mp.get(key,[])+[st]
        
        return list(mp.values())
```

#### [[动态规划]-53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215155827374.png" alt="image-20201215155827374" style="zoom:50%;" />

> **A:** 动态规划，DP[i]表示以nums[i]为结尾的连续子数组的最大和，递推公式是如果i-1的最大和+nums[i]比nums[i]大，那么nums[i]和前i-1个连起来形成新的连续子列，否则nums[i]单独成为连续子数组
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        #DP[i]表示以nums[i]为结尾的子数组最大和
        n = len(nums)
        dp = [0 for i in range(n+1)]
        r = float('-inf')
        for i in range(1,n+1):
            dp[i] = max(0,dp[i-1]) + nums[i-1]
            r = max(r,dp[i])
        return r
#前缀和的方法，连续数组最大值即为当前的前缀和减去最小的前缀和即可
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        #DP也行
        #前缀和？
        if not nums: return 0
        n = len(nums)
        minsum = min(nums[0],0)
        output = nums[0]
        cursum = nums[0]
        for i in range(1,n):
            cursum += nums[i]
            output = max(output,cursum-minsum)
            minsum = min(minsum,cursum)
        return output
```

#### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

类似网格类题目，四个方向不断轮换，走出去了用out判断之后再回来，另外已经走过的标记为"1"

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]: return []
        m,n = len(matrix),len(matrix[0])
        output = []
        directions = [(0,1),(1,0),(0,-1),(-1,0)]
        i,j,x = 0,-1,0
        def out(i,j):
            if i < 0 or j < 0 or i >= m or j >= n or matrix[i][j] == '1':
                return False
            return True
        while len(output) != m*n:
            di,dj = directions[x]
            while True:
                i,j = i+di,j+dj
                if out(i,j):
                    output.append(matrix[i][j])
                    matrix[i][j] = '1'
                else:
                    i,j = i-di,j-dj
                    break
            x = (x+1)%4
        return output
```



#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222141608499.png" alt="image-20201222141608499" style="zoom:50%;" />

> **A:** 贪心算法做，思路是如果能走到某个index，**那么index之前的所有都可以走到**（关键点），因为是一步步走的不能跳跃
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        maxlen = 0 #能跳到最远的位置，初始化为起点0
        n = len(nums)
        for i in range(n):
            if i > maxlen:
                return False
            maxlen = max(maxlen,nums[i]+i) #更新最远位置
        return True
```

#### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222150159736.png" alt="image-20201222150159736" style="zoom:50%;" />

> **A:** 判断后面区间是否和前面重合即可
```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if len(intervals) == 0: return []
        res = []
        intervals.sort()  # 先按区间左边界值由小到大排序
        for inter in intervals:
            if len(res) == 0 or res[-1][1] < inter[0]:  
                # 如果结果集最后一个元素的右边界比新加入区间的左边界小，直接加入结果集
                res.append(inter)
            else:  # 否则，说明新加入的和结果集最后一个区间有重合，更新区间右边界即可
                res[-1][1] = max(res[-1][1], inter[1])
        return res
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if not intervals: return []
        intervals = sorted(intervals)
        n = len(intervals)
        output = [intervals[0]]
        for i in range(1,n):
            if output[-1][1] < intervals[i][0]: #如果两个区间不挨着，append
                output.append(intervals[i])
            else:
                output[-1][1] = max(output[-1][1],intervals[i][1]) #否则取大的右区间
        return output
```

#### [[动态规划]-62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214151608861.png" alt="image-20201214151608861" style="zoom:50%;" />

> **A:**二维动态规划，状态转移方程比较简单，类似小时候学的最短路径问题，可优化为1D
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        #2D-DP
        # dp = [[1 for i in range(m)] for j in range(n)]
        # for i in range(1,n):
        #     for j in range(1,m):
        #         dp[i][j] = dp[i-1][j] + dp[i][j-1]
        # return dp[-1][-1] 
        dp = [1 for i in range(m)]
        for i in range(1,n):
            for j in range(1,m):
                dp[j] = dp[j] + dp[j-1]
        return dp[-1]
```

#### [[动态规划]-64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214151104745.png" alt="image-20201214151104745" style="zoom:50%;" />

> **A:** 二维动态规划，状态转移方程从左和上更新即可
```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        #DP[i][j]表示grid[i-1][j-1]的最小路径
        #2D-DP，加0的一行一列不用判断特殊情况
        if not grid: return 0
        m,n = len(grid),len(grid[0])
        for i in range(1,n): grid[0][i] += grid[0][i-1]
        for j in range(1,m): grid[j][0] += grid[j-1][0]
        for p in range(1,m):
            for q in range(1,n):
                grid[p][q] += min(grid[p-1][q],grid[p][q-1])
        return grid[-1][-1]
    
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        #DP[i][j]表示grid[i][j]的最小路径，优化到1D空间
        m,n = len(grid),len(grid[0])
        dp = [grid[0][0]]
        for i in range(1,n):
            dp.append(dp[-1]+grid[0][i])
        for i in range(1,m):
            for j in range(n):
                if j == 0:
                    dp[j] = dp[j]+grid[i][j]
                else:
                    dp[j] = min(dp[j],dp[j-1])+grid[i][j]
        return dp[-1]
```

#### [[动态规划]-70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214142220061.png" alt="image-20201214142220061" style="zoom:50%;" />

> **A:** 动态规划鼻祖类问题，斐波那契数列
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [1 for i in range(n+1)]
        for i in range(2,n+1):
            dp[i] = dp[i-1]+dp[i-2]
        return dp[-1]
```

#### [[动态规划]-72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222160047147.png" alt="image-20201222160047147" style="zoom:50%;" />

> **A:** 动态规划，看似和1143和583相似，其实不一样；假如当前i和j位置两字符串字母相同，则dpij=dpi-1j-1；若不相同，对单词1有三种操作方法：① 替换i位置的字母使其和单词2j位置的相同，剩下的为dpi-1j-1 + 1 ② 删除i位置字母，为dpi-1j + 1 ③ 添加单词2j位置的字母，结果为dpij-1 + 1，看哪个最小即可。注意初始化
```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        #DP[i][j]表示word1前i个和word2前j个相同，所需要对word1进行的操作所变次数
        m,n = len(word1),len(word2)
        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]
        #DP[0][j]和DP[j][0]表示从空字符串到word2，以及从word1到空字符串的数量
        dp[0] = [i for i in range(n+1)]
        for j in range(m+1): dp[j][0] = j
        for i in range(1,m+1):
            for j in range(1,n+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1] #若相等就继承
                else:
                    dp[i][j] = min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j]) + 1 #替换、添加[i,j-1]和删除操作的最小值+1
        return dp[-1][-1]
```

#### [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201229153921999.png" alt="image-20201229153921999" style="zoom:50%;" />

> **A:** 两个二分查找先找行，再找列，注意第一个二分查找是找到有序数列中最后一个比target=k小的位置
```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        #两个二分查找
        m,n = len(matrix),len(matrix[0])
        #先确定行，在确定列
        s1 = [matrix[i][0] for i in range(m)]
        r = self.bs(s1,target)
        c = self.bs(matrix[r],target)
        if matrix[r][c] == target: return True
        else: return False
    
    def bs(self,seq,k): #二分查找
        n = len(seq)
        l,r = 0,n-1
        while l <= r:
            mid = l + (r-l)//2
            if seq[mid] == k: return mid
            elif seq[mid] > k: r = mid-1
            else: l = mid+1
        return r
```

#### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222163838247.png" alt="image-20201222163838247" style="zoom:50%;" />

> **A:** 题目不难，但是一次遍历不容易想到，双指针分别代指0和2的位置，遇到0往前送，遇到2往后送，注意遇到2比较特殊，因为有可能原来位置也是2（故采用while），0则不存在这种情况
```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        #类似283移动零问题，只不过现在有两种数字0和2要移动
        #故采取双指针的方法
        n = len(nums)
        i,j = 0,n-1		
        for x in range(n):
            while x < j and nums[x] == 2: #保证x在j之前，不然会交换回来
                nums[x],nums[j] = nums[j],nums[x]
                j -= 1
            while x > i and nums[x] == 0: #保证x在i之后，不然会交换回来
                nums[x],nums[i] = nums[i],nums[x]
                i += 1 
```

#### [[滑动窗口]-76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223105338312.png" alt="image-20201223105338312" style="zoom:50%;" />

> **A:** 题目是滑动窗口（思想就是求以s所有index为起点包含t的最短长度），但是滑动窗口的部分不难，难的是如果判断更新要求，故额外增加一个counter来表示是否包含了字符串t，见[题解](https://leetcode-cn.com/problems/minimum-window-substring/solution/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/)；ij用ij来模拟滑动窗口，先扩大j找到包含t的然后缩小i直到不完全包含t，之后继续扩大j直到n；判断包含需要need和needCnt两个变量
```python
# ij用ij来模拟滑动窗口，先扩大j找到包含t的然后缩小i直到不完全包含t，之后继续扩大j直到n；判断包含需要need和needCnt两个变量
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        #滑动窗口的思想，扩展j让i-j包含t，然后扩展i使其不包含
        n,m = len(s),len(t)
        hashmap = {}
        for i in t:
            hashmap[i] = hashmap.get(i,0)+1
        l,r,count = 0,0,m #count用来优化查找，不然需要每次都遍历字典
        output = ""
        for r in range(n):
            if s[r] in hashmap:
                hashmap[s[r]] -= 1
                if hashmap[s[r]] >= 0: #说明有用
                    count -= 1
                while count == 0: #等于0说明s[l:r+1]包含t了
                    if not output or r-l+1 < len(output):
                        output = s[l:r+1]
                    if s[l] in hashmap:
                        hashmap[s[l]] += 1
                        if hashmap[s[l]] > 0:
                            count += 1
                    l += 1
        return output
```

#### [[回溯]-78. 子集](https://leetcode-cn.com/problems/subsets/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223111357707.png" alt="image-20201223111357707" style="zoom:50%;" />

> **A:** 回溯法和python方法，回溯法的专题看[这里](https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/)
```python
class Solution: #python方法，新元素在旧的基础上加
    def subsets(self, nums: List[int]) -> List[List[int]]:
        if not nums: return []
        n = len(nums)
        output = [[],[nums[0]]]
        for i in range(1,n):
            output += [x+[nums[i]] for x in output]
        
        return output

    
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        #回溯法，且不需要排列，只要组合
        n = len(nums)
        output = []
        r = []
        def traceback(index):
            output.append(r[:])
            for i in range(index,n):
                r.append(nums[i])
                traceback(i+1) #每一个元素进入sub之后，代表sub之前的元素都用过了
                r.pop()
        traceback(0)
        return output
```

#### [[回溯]-79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223142814018.png" alt="image-20201223142814018" style="zoom:50%;" />

> **A:** 回溯法，如果board\[i\]\[j\]==word[k]则继续找四个方向是否可以往下走（不行就退回即回溯），直到走到字符串word的尽头；temp也可以放在外面，每次pop，会快一些
```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        #回溯法
        directions = [(0,1),(1,0),(-1,0),(0,-1)]
        l,r,n = len(board),len(board[0]),len(word)
        visited = set() #用set查询是O(1)
        #代表从board的(i,j)出发能否搜索到word[k:]
        def traceback(i,j,k): 
            if i < 0 or j < 0 or i >= l or j >= r: #越界直接False
                return False
            if board[i][j] != word[k]:
                return False
            #除去上述情况，即当前步可以继续往下走，先判断是否走到最后一位了，后更新visited
            if k == n-1:
                return True
    
            visited.add((i,j))
            for di,dj in directions:
                if (i+di,j+dj) not in visited and traceback(i+di,j+dj,k+1):
                    return True
            visited.remove((i,j)) #记得走完这一步退回去
            return False
        for i in range(l):
            for j in range(r):
                if traceback(i,j,0):
                    return True
        return False
```

#### [[单调栈]-84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223153822541.png" alt="image-20201223153822541" style="zoom:50%;" />

> **A:** 单调递增栈，**对所有柱子的高度进行遍历**。对于某一根柱子来说，以他为高的最大面积来自于左右第一个比他小的柱子的位置，即heights[index]\*(right-left-1)，类似42（84是两小夹一大，42是两大夹一小）
```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        #单调栈，思想是碰到一个较小的值k后，左侧所有比k大的值都没用了，相对他们来说k就是右侧第一个小值
        #对于每个柱子来说，找到左右两边第一个比他短的位置就是他的高度能构成的最大面积
        #维护一个单调递增的栈，遇到新的元素比栈顶元素小，说明栈顶的要pop了，要计算面积了
        heights = [0] + heights + [0] #左加0为的是pop最后一个元素的时候，右加0为的是防止柱子高度递增不会进入while循环
        n = len(heights)
        stack = []
        output = 0
        for i in range(n):
            while stack and heights[stack[-1]] > heights[i]:
                index = stack.pop()
                left = stack[-1] #当index被pop时，因为栈内单调增，故stack[-1]栈顶就是left小位置，i就是right小的位置
                right = i
                output = max(output,heights[index]*(right-left-1))
            stack.append(i)
        return output
```

#### [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223182609359.png" alt="image-20201223182609359" style="zoom:50%;" />

> **A:** 这个题目还有更简单的方法，现在只能理解这一种，先按行找到每个点为右下角可能的最大矩形，然后按列找真正的最大矩形
```python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        maxarea = 0

        dp = [[0] * len(matrix[0]) for _ in range(len(matrix))]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == '0': continue

                # compute the maximum width and update dp with it
                width = dp[i][j] = dp[i][j-1] + 1 if j else 1

                # compute the maximum area rectangle with a lower right corner at [i, j]
                for k in range(i, -1, -1):
                    width = min(width, dp[k][j])
                    maxarea = max(maxarea, width * (i-k+1))
        return maxarea
    
#利用84中单调栈的解法优化
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]: return 0
        m,n = len(matrix),len(matrix[0])
        #先按列求每个matrix[i][j]为右下角元素的矩阵的可能max行，即matrix[i][j]上侧连续的1的个数
        dp = [[0]*n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    dp[i][j] = dp[i-1][j]+1 if i > 0 else 1
        #每一行作为84的一个列表，遍历即可，复杂度O(nm)
        output = 0
        for i in range(m):
            #print(dp[i])
            output = max(output,self.q84(dp[i]))
        return output
        

    def q84(self,height):
        #两小夹一大，单调递增栈
        height = [0] + height + [0]
        n = len(height)
        stack = []
        output = 0
        for i in range(n):
            while stack and height[stack[-1]] > height[i]:
                index = stack.pop()
                left = stack[-1]
                right = i
                output = max(output,height[index]*(right-left-1))
            stack.append(i)
        return output
```

#### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

类似反转链表，一次遍历可以完成，记录子串头节点的前一个节点（方便安放头节点）和子串的tail节点（方便连接后面）为pre和cur，不断将后面的节点挪到头节点即可达到翻转的效果

```python
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        #找到头节点的前一个节点和尾节点
        dummy = ListNode(next=head)
        pre = dummy
        for i in range(left-1):
            pre = pre.next
        cur = pre.next
        #pre和cur分别是头节点的前一个节点（可以理解为子串的dummy）和尾节点
        for i in range(right-left):
            tmp = cur.next
            cur.next = tmp.next
            tmp.next = pre.next #这里把tmp放在原来头节点的前面
            pre.next = tmp
        return dummy.next
```

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> **Q:** 

中序遍历

> **A:** 
```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if not root: return []
        stack = []
        node = root
        output = []
        while stack or node:
            while node:
                stack.append(node)
                node = node.left
#这时出来的P就是当前结点最左边的左儿子，将他的值放进res，然后遍历他的右子树，此时如果没有右子树，则新P为NONE，下一个P就是stack.pop()，也就是当前结点的父亲
            node = stack.pop()
            output.append(node.val)
            node = node.right
        return output
```

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213120731988.png" alt="image-20201213120731988" style="zoom:50%;" />

> **A:** 动态规划做，找到更新公式
```python
class Solution:
    def numTrees(self, n: int) -> int:
        #DP[i]表示i个节点种数，(DP[0]*DP[i-1])+(DP[1]*DP[i-2])+...+(DP[i-2]*DP[1])+(DP[i-1]*DP[0])
        #1-n每个节点都可能为根节点，种数就是左子树*右子树
        dp = [0 for i in range(n+1)]
        dp[0] = dp[1] = 1
        for i in range(2,n+1):
            for j in range(i):
                dp[i] += dp[i-j-1]*dp[j]
        return dp[-1]
```

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213132158453.png" alt="image-20201213132158453" style="zoom:50%;" />

> **A:** 搜索二叉树中序遍历有序/或者使用递归，注意子树要加minmax限制
```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack,temp,p = [],float('-inf'),root
        while stack or p:
            while p:
                stack.append(p)
                p = p.left
            p = stack.pop()
            if p.val > temp: temp = p.val
            else: return False
            p = p.right

        return True
#递归的方法
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        #左子树所有值要小于root.val，右子树所有值要大于root.val
        def inner(root,down,up):
            if not root: return True
            if root.val <= down or root.val >= up:
                return False
            leftup = min(root.val,up)
            rightdown = max(root.val,down)
            return inner(root.left,down,leftup) and inner(root.right,rightdown,up)
        return inner(root,float('-inf'),float('inf'))
```

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209185219453.png" alt="image-20201209185219453" style="zoom:50%;" />

> **A:** 递归和迭代，迭代就用层序遍历但是要一次输入输出两个节点对应左右两个子树
```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        #递归比较根节点的左右子树是否为镜像
        def inner(left,right):
            if not left and not right: return True
            if not left or not right: return False
            if left.val != right.val: return False
            return inner(left.right,right.left) and inner(left.left,right.right)
        if not root: return True
        return inner(root.left,root.right)
        
        #层序遍历BFS
        if not root or (not root.left and not root.right): return True
        if not root.left or not root.right: return False
        queue = [(root.left,root.right)]
        while queue:
            n1,n2 = queue.pop(0)
            if not n1 and not n2: continue
            if not n1 or not n2 or n1.val != n2.val: return False
            queue.append((n1.left,n2.right))
            queue.append((n1.right,n2.left))
        
        return True
```


#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209141440946.png" alt="image-20201209141440946" style="zoom:50%;" />

> **A:** 层序遍历，同时记录当前层数depth，和curdep比较，不一样了说明进入下一层
```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        #层序遍历队列
        if not root: return []
        queue = [(root,0)]
        output = [[]]
        depth = 0
        while queue:
            node,d = queue.pop(0)
            if d > depth:
                output.append([])
                depth = d
            output[-1].append(node.val)
            if node.left:
                queue.append((node.left,d+1))
            if node.right:
                queue.append((node.right,d+1))
        return output
```

#### [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

变种层序遍历，决定头部插入还是尾部插入

```python
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        #z形层序遍历
        queue = [(root,0)]
        depth = -1
        output = []
        while queue:
            node,d = queue.pop(0)
            if node.left:
                queue.append((node.left,d+1))
            if node.right:
                queue.append((node.right,d+1))
            if d > depth:
                output.append([])
                depth = d
            if d % 2 == 0:
                output[-1].append(node.val)
            else:
                output[-1].insert(0,node.val)
        return output
```

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213132629521.png" alt="image-20201213132629521" style="zoom:50%;" />

> **A:** 递归简单一些，递归的方法都可以用层序遍历做
```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        # if not root: return 0
        # return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1
        # 层序遍历，先进先出，队列
        if not root: return 0
        queue = [(root,1)]
        while queue:
            node,depth = queue.pop(0)
            if node.left: queue.append((node.left,depth+1))
            if node.right: queue.append((node.right,depth+1))
        return depth
#递归方法
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root: return 0
        if not root.left and not root.right: return 1
        left = self.maxDepth(root.left)
        right = self.maxDepth(root.right)
        return max(left,right)+1
```

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213135313850.png" alt="image-20201213135313850" style="zoom:50%;" />

> **A:** 前序=根+左子树+右子树；中序=左子树+根+右子树；找到根，确定左右子树的前中序，递归下去就行
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        #找到根节点和左右子树，递归
        if not preorder: return 
        root = TreeNode(preorder[0])
        leftlen = inorder.index(root.val) #左子树结点数
        root.left = self.buildTree(preorder[1:leftlen+1],inorder[:leftlen])
        root.right = self.buildTree(preorder[leftlen+1:],inorder[leftlen+1:])
        return root
```

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209154834106.png" alt="image-20201209154834106" style="zoom:50%;" />

> **A:** 递归简单一些，递归的方法都可以用层序遍历做
```python
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        #没想到递归只想到了层序遍历，第二次想到了递归
        if not root: return False
        queue = [(root,root.val)]
        while queue:
            node,pathsum = queue.pop(0)
            if node.left: queue.append((node.left,pathsum+node.left.val))
            if node.right: queue.append((node.right,pathsum+node.right.val))
            if not node.left and not node.right and pathsum == sum: return True
        return False
        
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
            if not root: return False
            if not root.left and not root.right and sum - root.val == 0:return True
            return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)
```

#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213140958755.png" alt="image-20201213140958755" style="zoom:50%;" />

> **A:** 顺序是按照前序遍历，之后全放在右子树上；还有一种优化O(1)空间的方法，对每个节点如果有左子树就把右子树挂在左子树最右边的节点上
```python
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root: return
        def psearch(root):
            output = []
            stack = []
            node = root
            while stack or node:
                while node:
                    output.append(node)
                    stack.append(node)
                    node = node.left
                node = stack.pop().right
            return output
        nodes = psearch(root)
        for i in range(len(nodes)-1):
            nodes[i].right = nodes[i+1]
            nodes[i].left = None
        nodes[-1].left = None
        nodes[-1].right = None
#优化到O(1)空间        
class Solution:
    def flatten(self, root: TreeNode) -> None:
        curr = root
        while curr:
            if curr.left:
                predecessor = nxt = curr.left
                while predecessor.right:
                    predecessor = predecessor.right #找到最右边的节点
                predecessor.right = curr.right
                curr.left = None
                curr.right = nxt
            curr = curr.right
```

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215160807578.png" alt="image-20201215160807578" style="zoom:50%;" />

> **A:** 记录minprice，那么当前最大的收益（prices[i] > minprice）就是prices[i]-minprice，否则更新minprice；
```python
#按卖出遍历
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices: return 0
        maxp,minprice,n = 0,prices[0],len(prices)
        for i in range(1,n):
            if prices[i] > minprice: maxp = max(maxp,prices[i]-minprice)
            else: minprice = prices[i]
        
        return maxp
#按买入遍历
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        #nums[i+1:]的max-nums[i]就是i当天买入获利的最大值，倒序遍历
        if not prices: return 0
        n = len(prices)
        maxprice = prices[-1]
        output = 0
        for i in range(n-2,-1,-1):
            output = max(output,maxprice-prices[i])
            maxprice = max(maxprice,prices[i])
        return output
```

#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)


> **Q:** 和543求树的直径类似，利用递归过程更新max

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209195056629.png" alt="image-20201209195056629" style="zoom:50%;" />

> **A:** 递归，maxlen计算以当前根节点为起点的max路径和，对于每个根节点来说，最终最大路径就是val+leftmax+rightmax
```python
class Solution:
    def __init__(self):
        self.output = float('-inf')
    def maxPathSum(self, root: TreeNode) -> int:
        #构造maxlen函数计算以node为起点的向下的max和，最大路径和就是node.val+leftmax+rightmax
        def maxSum(node):
            if not node: return 0
            left = max(maxSum(node.left),0)
            right = max(maxSum(node.right),0)
            self.output = max(self.output,left+right+node.val)
            return max(left,right)+node.val
        maxSum(root)
        return self.output
```

#### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226134342810.png" alt="image-20201226134342810" style="zoom:50%;" />


> **A:** hashmap简化查询，同时利用查询hm[j-1]是否存在的方法消除冗余
```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        #hashmap存放所有的元素加速查找
        hashmap = set(nums)
        output = 0
        for i in hashmap:
            if i-1 not in hashmap:
                start = i
                while start in hashmap:
                    start += 1
                output = max(output,start-i)
        return output
```

#### [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

递归或者层序遍历应该都可以做

```python
class Solution:
    def __init__(self,):
        self.output = 0
    def sumNumbers(self, root: TreeNode) -> int:
        def inner(root,s):
            if not root: return
            s += str(root.val)
            if not root.left and not root.right:
                self.output += int(s)
            inner(root.left,s)
            inner(root.right,s)
        inner(root,'')
        return self.output
```

#### [[位运算]-136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

> **Q:** 

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226143459675.png" alt="image-20201226143459675" style="zoom:50%;" />


> **A:** 自己的想法是集合*2-列表，用位运算可以将空间优化到O(1)。
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return sum(set(nums))*2-sum(nums)

class Solution: #位运算，异或运算，a^a = 0，0^a=a，剩下的就是单个的
    def singleNumber(self, nums: List[int]) -> int:
        #异或运算
        output = 0
        for num in nums:
            output ^= num
        return output
```

#### [[完全背包]-139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215152231138.png" alt="image-20201215152231138" style="zoom:50%;" />

> **A:** 完全背包问题但是数据结构变化了，dp[i]表示s[0:i]是否能用wordDict表示，递推公式为遍历j有(dp[j] and s[j:i] in wordDict) or dp[i]。这个题目有顺序的情况下，不能直接套用完全背包问题。这个人总结的不错[这里](https://leetcode-cn.com/problems/word-break/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-we-4/)
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        #DP[i]表示s[:i]能否被拆分
        n = len(s)
        dp = [False]*(n+1)
        dp[0] = True
        for i in range(1,n+1):
            for j in range(i):
                if s[j:i] in wordDict and dp[j]: #遍历s[:i]的所有连续子串，s[j:i]在dict种且dp[j]可以的就可以
                    dp[i] = True
        return dp[-1]
```

#### [[链表]-141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226144858817.png" alt="image-20201226144858817" style="zoom:50%;" />

> **A:** 如何判断是否为环，快慢指针，快的如果能和慢的相等说明存在环（即超了一圈儿），且由于速度是1和2故必定会相遇
```python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        #快慢指针
        s = f = head
        while f and f.next:
            s = s.next
            f = f.next.next
            if s == f: return True
        return False
```

#### [[链表]-142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226152735343.png" alt="image-20201226152735343" style="zoom:50%;" />

> **A:** 类似141，当快慢指针相遇时，从头节点开始一个新的指针n，当n和s再次相遇即为环头，证明见[这里](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/)
>
> 相遇时慢指针走了a+b，快指针走了a+(b+c)n+b，且快是慢的2倍，推得a = (n-1)(b+c) + c，即此时new从head走和s从相遇点走终会相遇
```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        s = f = head
        while f:
            s = s.next
            f = f.next
            if f: 
                f = f.next
                if s == f:
                    break
        if not f: return None
        new = head
        while new != s: #新指针从头走起，直到和慢指针在环头相遇
            s = s.next
            new = new.next
        return new
```

#### [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

找中点+倒序+拼接，但是这个题目偶数找左边的更好做一些，需要特殊判断，和回文链表那个不同

```python
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        #找中点+逆序+穿插
        if not head or not head.next: return head
        node = head.next
        def findmid(head):
            if not head or not head.next: return head
            #偶数要是左边的，奇数找中点
            s = f = head
            while f and f.next and f.next.next:
                s = s.next
                f = f.next.next
            return s
        def reverse(head):
            pre,cur = None,head
            while cur:
                tmp = cur.next
                cur.next = pre
                pre,cur = cur,tmp
            return pre
        mid = findmid(node) #找中点
        righthead = reverse(mid.next) #倒序后半边
        mid.next = None #切断连接
        lefthead = head.next
        node = head
        while righthead:
            print(lefthead.val,righthead.val)
            node.next = righthead
            righthead = righthead.next
            node = node.next
            node.next = lefthead
            node = node.next
            lefthead = lefthead.next        
        return head
```



#### [[链表（双向）+哈希表]-146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226155557914.png" alt="image-20201226155557914" style="zoom:50%;" />

> **A:** 双向链表+哈希表，其中双向链表记录使用历史，哈希表记录key-value。需要做的操作是删除节点+添加头节点（因为添加肯定是history的第一个）
```python
#双向链表+哈希表（字典），其中双向链表记录使用历史，哈希表记录key-value pair
class BiLink:
    def __init__(self,key=0,value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:

    def __init__(self, capacity: int):
        self.cache = dict()
        self.head = BiLink()
        self.tail = BiLink()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.capacity = capacity
        self.size = 0

    def get(self, key: int) -> int:
        if key not in self.cache: return -1
        # 如果 key 存在，先通过哈希表定位，再删除移到头部
        node = self.cache[key]
        self.removeNode(node)
        self.addTohead(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key not in self.cache:
            # 如果 key 不存在，创建一个新的节点
            node = BiLink(key,value)
            # 添加进哈希表
            self.cache[key] = node
            self.size += 1
            # 添加至双向链表的头部
            self.addTohead(node)
            # 如果超出容量，删除双向链表的尾部节点和cache中对应key
            if self.size > self.capacity:
                node = self.removeTail()
                self.cache.pop(node.key)
                self.size -= 1
        else:
            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node = self.cache[key]
            node.value = value
            self.removeNode(node)
            self.addTohead(node)     

    def removeNode(self,node):
        node.prev.next = node.next
        node.next.prev = node.prev
        return node

    def removeTail(self):
        return self.removeNode(self.tail.prev)
    
    def addTohead(self,node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
```

#### [[链表]-147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201226170737969.png" alt="image-20201226170737969" style="zoom:50%;" />

> **A:** 加dummy省去判断特殊情况，然后按从小到大的顺序进行插入排序即可
```python
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        if not head or not head.next: return head
        dummy = ListNode(next=head)
        tmp = dummy #每次序列的头
        node = head.next #每次要插入的节点
        head.next = None
        while node:
            while tmp.next and node.val > tmp.next.val: #这里是判断tmp的next，因为要差到tmp后面
                tmp = tmp.next
            #插到tmp后面，同时更新node和tmp
            cur = node.next
            node.next = tmp.next
            tmp.next = node
            node = cur
            tmp = dummy
        return dummy.next
```

#### [[链表]148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227140705645.png" alt="image-20201227140705645" style="zoom:50%;" />

> **A:** 归并排序，注意细节
```python
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        #NlogN的三种：归并、堆和快速排序
        #找到中点，排序左右子列，然后merge两个有序列表
        #需要有tail的概念来完善链表的头尾
        def merge(l1,l2):
            dummy = ListNode()
            head = dummy
            while l1 and l2:
                if l1.val <= l2.val:
                    head.next = l1
                    l1 = l1.next
                else:
                    head.next = l2
                    l2 = l2.next
                head = head.next
            if l1: head.next = l1
            if l2: head.next = l2
            return dummy.next

        def merge_sort(head,tail):
            if not head: return head
            if head.next == tail: #加这一步很关键，因为是左闭右开，故tail和head直接连接时相当于只有head，输出即可
                head.next = None #这一步None很必须，相当于在连接处断开和后半段的连接
                return head
            #类似归并排序，找中点
            slow,fast = head,head
            while fast != tail and fast.next != tail:
                slow = slow.next
                fast = fast.next.next
            mid = slow
            l1,l2 = merge_sort(head,mid),merge_sort(mid,tail)
            return merge(l1,l2)

        return merge_sort(head,None)
```

#### [[动态规划]-152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227145009849.png" alt="image-20201227145009849" style="zoom:50%;" />

> **A:** 动态规划，考虑到负数的存在，要找以当前nums[i]结尾的连乘的max和min的两个累计值，然后递推一致；可以优化到1D
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        #两个DP同时记录以数字i为结尾的最小乘积和最大乘积
        if not nums: return 0
        n = len(nums)
        adp = [1 for i in range(n)]
        idp = [1 for i in range(n)]
        adp[0] = idp[0] = nums[0]
        for i in range(1,n):
            if nums[i] >= 0: #可以优化到1D
                adp[i] = max(adp[i-1]*nums[i],nums[i])
                idp[i] = min(idp[i-1]*nums[i],nums[i])
            else:
                adp[i] = max(idp[i-1]*nums[i],nums[i])
                idp[i] = min(adp[i-1]*nums[i],nums[i])
        return max(adp)          
    
class Solution: #优化到1D
    def maxProduct(self, nums: List[int]) -> int:
        #因为存在负数，故需要一个最大和最小的数组
        #当前为正数，最大数组=max(rdp[i-1],1)*nums[i]，最小数组为min(ldp[i-1],1)*nums[i]
        #当前为负数，最大数组=min(ldp[i-1],1)*nums[i]，最小数组为max()
        n = len(nums)
        ldp,rdp = 1,1
        output = float('-inf')
        for i in range(1,n+1):
            if nums[i-1] > 0:
                rdp = max(rdp,1) * nums[i-1]
                ldp = min(ldp,1) * nums[i-1]
            else:
                tmp = ldp
                ldp = max(rdp,1) * nums[i-1]
                rdp = min(tmp,1) * nums[i-1]    
            output = max(output,rdp) 
        return output
```

#### [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

二分查找不断更新最小值，初始化nums[0]为最小值，遇到小于target的更新

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        #二分查找
        if not nums: return
        target = nums[0]
        n = len(nums)
        l,r = 0,n-1
        while l <= r:
            mid = l+(r-l)//2
            if nums[mid] >= target: #取等是防止[2,1]这样的逆序
                l = mid+1
            else:
                target = nums[mid]
                r = mid-1
        return target
```

#### [[栈]-155. 最小栈](https://leetcode-cn.com/problems/min-stack/)


> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227150531802.png" alt="image-20201227150531802" style="zoom:50%;" />

> **A:** 这次做想多了，考虑到栈的特点，后入栈的比当前最小值i大的元素都不用记录，因为他们肯定比最小值i先出栈
```python
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        #维护是一个单调递减的栈，这个栈不变的话， 最小值不变化
        self.minstack = []
        self.stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.minstack or self.minstack[-1] >= val:
            self.minstack.append(val)


    def pop(self) -> None:
        val = self.stack.pop()
        if val == self.minstack[-1]:
            self.minstack.pop()
        return val

    def top(self) -> int:
        return self.stack[-1]


    def getMin(self) -> int:
        return self.minstack[-1]
```

#### [[链表]-160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213114036501.png" alt="image-20201213114036501" style="zoom:50%;" />

> **A:** 将两个链表连在一起，这样最后总会遍历到相同点，这一思想被236所采纳，即序列尾部相同找相同点
```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        l1,l2 = headA,headB
        while l1!=l2:
            l1 = l1.next if l1 else headB
            l2 = l2.next if l2 else headA
        return l1
```

#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227151337268.png" alt="image-20201227151337268" style="zoom:50%;" />

> **A:** hashmap或投票法，核心思想是大于一半的众数只有一个
```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        if not nums: return
        n = len(nums)
        k = n//2+1
        from collections import defaultdict
        hm = defaultdict(int)
        for i in range(n):
            hm[nums[i]] += 1
            if hm[nums[i]] == k: return nums[i]
#投票法candidate代表选举人，count代表票数，票数为0换人，相同的+1不同的-1
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        #投票法
        if not nums: return
        n = len(nums)
        count = 0
        for i in range(n):
            if count == 0: candidate = nums[i]
            if candidate == nums[i]: count += 1
            else: count -= 1
        return candidate
```

#### [[位运算]-191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201230161822512.png" alt="image-20201230161822512" style="zoom:50%;" />

> **A:** n和n-1的**与**运算会把n的最后一个1去掉，去掉一个1就output+=1，直到n为0，这个算法叫做**布赖恩·克尼根算法**；[python位运算](https://www.runoob.com/python/python-operators.html)
```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        output = 0
        while n != 0:
            n &= n-1
            output += 1
        return output
```

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201214142845928.png" alt="image-20201214142845928" style="zoom:50%;" />

> **A:** 动态规划
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        #要明确DP[i]的含义，是只有nums[:i]家的时候能偷的最大值，如果偷i，那么i-1一定不能偷了，就是前i-2的max
        #定义成立，递推成立，结果就成立，不要过分关注细节
        if not nums: return 0
        n = len(nums)
        dp = [0 for i in range(n+1)]
        dp[1] = nums[0]
        for i in range(2,n+1):
            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1])
        return dp[-1]
#简化到O(1)空间
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums: return 0
        n = len(nums)
        a,b = 0,nums[0]
        for i in range(2,n+1):
            temp = max(a+nums[i-1],b)
            a,b = b,temp
        return b
```

#### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

层序遍历记录每一层的最后一个节点值

```python
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root: return []
        #每一层的最后一个节点值
        queue = [(root,0)]
        output = []
        pre = -1 #用pre来记录上一层的最后一个值，一旦depth变化，把pre加入output
        depth = 0
        while queue:
            node,d = queue.pop(0)
            if d > depth:
                output.append(pre)
                depth = d
            pre = node.val
            if node.left:
                queue.append((node.left,d+1))
            if node.right:
                queue.append((node.right,d+1))
        output.append(pre)
        return output
```



#### [[DFS]-200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201227153007857.png" alt="image-20201227153007857" style="zoom:50%;" />

> **A:** DFS，要理解什么是岛屿，见[这里](https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)，解释的非常好
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m,n = len(grid),len(grid[0])
        def dfs(i,j):
            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != "1": #这些情况表示没办法走，边界and水and走过的地方
                return False
            grid[i][j] = "2" #走过的地方标记为2
            dfs(i-1,j) #继续走
            dfs(i,j-1)
            dfs(i+1,j)
            dfs(i,j+1)
            return True
        output = 0
        for i in range(m):
            for j in range(n):
                if dfs(i,j):
                    output += 1 #走通一次就是一个岛屿
        return output
#传递grid的方法
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m,n = len(grid),len(grid[0])
        def dfs(grid,i,j):
            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != "1":
                return False,grid
            grid[i][j] = "2"
            _,grid = dfs(grid,i-1,j)
            _,grid = dfs(grid,i,j-1)
            _,grid = dfs(grid,i+1,j)
            _,grid = dfs(grid,i,j+1)
            return True,grid
        output = 0
        for i in range(m):
            for j in range(n):
                flag,grid = dfs(grid,i,j)
                if flag:
                    output += 1
        return output
```

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213142201635.png" alt="image-20201213142201635" style="zoom:50%;" />

> **A:** 反转链表竟然忘了，牢记！分对儿进行，记录next并反转，直到cur是None
```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre,cur = None,head
        while cur != None:
            temp = cur.next
            cur.next = pre
            pre,cur = cur,temp
        return pre
```

#### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

看到连续就想到了前缀和+二分查找，没想到还可以滑动窗口

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        #前缀和+二分搜索
        sums = [0]
        n = len(nums)
        r = 0
        for i in range(n):
            r += nums[i]
            sums.append(r)
        def bi_search(seq,target):
            n = len(seq)
            l,r = 0,n-1
            while l <= r:
                mid = l+(r-l)//2
                if seq[mid] == target:
                    return mid
                elif seq[mid] < target:
                    l = mid+1
                else:
                    r = mid-1
            return l
        output = n+1
        for i in range(n+1):
            index = bi_search(sums,target+sums[i]) #对于每个前缀和，找他+target能达到的最近的index，遍历即可
            if index < n+1 and sums[index] - sums[i] >= target:
                output = min(output,index-i)
        return output if output <= n else 0
#滑动窗口方法
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        i,j = 0,0
        r = 0
        output = n+1
        while j < n:
            while j < n and r < target:
                r += nums[j]
                j += 1
            while r >= target:
                output = min(output,j-i)
                r -= nums[i]
                i += 1
        if output == n+1: return 0
        return output
```



#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201216110515560.png" alt="image-20201216110515560" style="zoom:50%;" />

> **A:** 堆排序，建立最大堆；快速排序，平均复杂度均为O(NlogN)，空间复杂度为O(1)
```python
class Solution:
    def findKthLargest(self, nums, k: int) -> int:
        heap = self.make_heap(nums)
        for i in range(k):
            output,heap = self.heappop(heap)
        return output
    #最大堆的建立
    def make_heap(self,seq):
        n = len(seq)
        first = n//2 - 1 #第一个父节点的索引、
        for parent in range(first,-1,-1):
            seq = self.check(seq,parent)
        return seq
    #最大堆pop操作，即输出最大值    
    def heappop(self,seq):
        if not seq: return 
        if len(seq) == 1: return seq[0],[]
        output = seq[0]
        seq[0] = seq.pop()
        seq = self.check(seq,0)
        return output,seq
    #最大堆过滤操作
    def check(self,seq,parent):
        n = len(seq)
        while 2*(parent+1)-1 < n:
            child = 2*(parent+1)-1
            if child < n-1 and seq[child] < seq[child+1]:
                child += 1
            if seq[parent] < seq[child]:
                seq[parent],seq[child] = seq[child],seq[parent]
                parent = child
            else: break
        return seq
#快速排序    
class Solution:
    def findKthLargest(self, nums, k: int) -> int:
        n = len(nums)
        return self.quick_sort(nums)[n-k]

    def quick_sort(self,seq):
        n = len(seq)
        if n <= 1: return seq
        def inner(seq,l,r):
            if r-l < 2: 
                seq[l],seq[r] = sorted([seq[l],seq[r]])
                return seq
            mid = (l+r)//2
            seq[l],seq[mid],seq[r] = sorted([seq[l],seq[mid],seq[r]])
            seq[r-1],seq[mid] = seq[mid],seq[r-1]
            i,j,prior = l+1,r-2,seq[r-1] #只需要管l+1->r-2
            while True:
                while seq[i] <= prior and i < r-1: i += 1 #左指针不能超过主元的位置
                while seq[j] > prior: j -= 1
                if i > j: break
                seq[i],seq[j] = seq[j],seq[i]
            seq[i],seq[r-1] = seq[r-1],seq[i]
            inner(seq,l,i-1)
            inner(seq,i+1,r)
            return seq
        return inner(seq,0,n-1)
#归并排序
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if n < k: return 
        def merge_sort(seq):
            n = len(seq)
            if n <= 1: return seq
            mid = n // 2
            return merge(merge_sort(seq[:mid]),merge_sort(seq[mid:]))

        def merge(n1,n2):
            output = []
            while n1 and n2:
                if n1[0] > n2[0]:
                    output.append(n2.pop(0))
                else:
                    output.append(n1.pop(0))
            if n1: output += n1
            if n2: output += n2
            return output
        nums = merge_sort(nums)
        return nums[n-k]
```

#### [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201223164540702.png" alt="image-20201223164540702" style="zoom:50%;" />

> **A:** 动态规划，如果i,j是1则以i,j为右下角的正方形取决于dp\[i - 1\]\[j\], dp\[i\]\[j - 1\], dp\[i - 1\]\[j - 1\]的min+1，否则肯定为0
```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]: return 0
        #DP[i][j]代表以i,j为右下角的矩阵的最大正方形的边长
        m,n = len(matrix), len(matrix[0])
        dp = [[0]*n for _ in range(m)]
        maxlen = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]) + 1
                    maxlen = max(maxlen,dp[i][j])
        return maxlen**2
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

> **Q:**

翻转二叉树

> **A:** 递归简单一些，递归的方法都可以用层序遍历做
```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        #递归
        if not root: return
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left,root.right = right,left
        return root
        #迭代，层序遍历
        if not root: return root
        queue = [root]
        while queue:
            node = queue.pop(0)
            left,right = node.left,node.right
            if left: queue.append(left)
            if right: queue.append(right)
            node.left,node.right = right,left
        return root
```

#### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201228114256290.png" alt="image-20201228114256290" style="zoom:50%;" />

> **A:** O(1)的空间复杂度要把链表一分为二，然后逆转后半段和前半段比较
```python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        #找到后半部分链表+翻转后半部分链表+比较前后
        def findhalf(head):
            #要找的是奇数的中点右侧和偶数的右侧
            s,f = head,head
            while f: #这里只限制f是因为奇数时要往右多走一步
                s = s.next
                f = f.next
                if f: f = f.next
            return s
        #反转链表
        def reverse(head):
            pre,cur = None,head
            while cur:
                tmp = cur.next
                cur.next = pre
                pre,cur = cur,tmp
            return pre
        right = reverse(findhalf(head))
        while right:
            if right.val == head.val:
                right,head = right.next,head.next
            else: return False
        return True
```

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213112920703.png" alt="image-20201213112920703" style="zoom:50%;" />

> **A:** 迭代的思想最后来源于160链表公共点，序列尾部相同的查找
```python
class Solution: #层序遍历生成路径进行对比
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        #层序遍历记录父节点
        if not root: return
        fathers = {root:None}
        queue = [root]
        while queue:
            node = queue.pop(0)
            if node.left:
                fathers[node.left] = node
                queue.append(node.left)
            if node.right:
                fathers[node.right] = node
                queue.append(node.right)
        l1,l2 = p,q
        while l1!=l2:
            l1 = fathers.get(l1) if l1 else q #或者写为fathers.get(l1,q)
            l2 = fathers.get(l2) if l2 else p #fathers.get(l2,p)
        return l1
#递归，如果左右子树都找到了那么就说明root是最近        
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        #p和q一定在公共祖先的左右子树上
        if not root: return 
        if root == p or root == q: return root
        #如果root!=p且!=q，那么p和q有三种情况：左右-左左-右右
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        if left and right: return root
        if left: return left
        return right
```

#### [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201228120038315.png" alt="image-20201228120038315" style="zoom:50%;" />

> **A:** 两次遍历找到nums[i]左边所有数乘积和右边，然后L[i]*R[i]即可
```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        L,R,output = [1 for i in range(n)],[1 for i in range(n)],[1 for j in range(n)]
        for x in range(1,n):
            L[x] = L[x-1] * nums[x-1]
        for y in range(n-2,-1,-1):
            R[y] = R[y+1] * nums[y+1]
        for j in range(n):
            output[j] = L[j]*R[j]
        return output
#优化到O1空间复杂度，思路是两次遍历，一次积累i左边的所有乘积并乘，一次积累i右边的所有乘积并乘
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        output = [1]*n
        r = 1
        for i in range(n):
            output[i] *= r
            r *= nums[i]
        r = 1
        for i in range(n-1,-1,-1):
            output[i] *= r
            r *= nums[i]
        return output
```

#### [[滑动窗口]-239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

> **Q:**



> **A:** 找固定区间内的最值，第一时间想到分桶法，见官方解法3；用双向队列做了出来，思路是：l和r控制窗口大小，维护一个单调递减的双向队列，因为一旦有新的更大的元素入队（说明这个元素满足滑动窗口长度），之前的比它小的都没用了（肯定在一个区间内），以此类推，当r和l的距离达到k时最大值即为队首元素。
```python
#最大堆的方法
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        # 注意 Python 默认的优先队列是小根堆
        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)

        ans = [-q[0][0]]
        for i in range(k, n):
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] <= i - k:
                heapq.heappop(q)
            ans.append(-q[0][0])
        
        return ans
    #维护一个单调递减的双向队列，因为新入队的大元素会让队内元素失效
    #两次出队，尾部出队是大元素入队，头部出队是超过滑动窗口范围
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        #l,r表示滑动窗口
        #感觉可以用个单调递减栈，其实是双向队列

        n = len(nums)
        stack = deque()
        output = []
        l,r = 0,0
        for r in range(n):
            while stack and nums[stack[-1]] < nums[r]:
                stack.pop()
            stack.append(r)
            if r - l == k-1:
                while stack and stack[0] < l:
                    stack.popleft()
                output.append(nums[stack[0]])
                l += 1
        return output
```

#### [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201230153412893.png" alt="image-20201230153412893" style="zoom:50%;" />

> **A:** 可以按照对角线进行对行和列的二分搜索，复杂度O(logn!)；或者找左下角和右上角，然后比较更新i,j即可
```python
class Solution:
    def searchMatrix(self, matrix, target):
        #找左下角和右上角，左上角和右下角不行，是min和max
        
        #选左上角，往右走和往下走都增大，不能选

        #选右下角，往上走和往左走都减小，不能选

        #选左下角，往右走增大，往上走减小，可选

        #选右上角，往下走增大，往左走减小，可选
        if not matrix: return False
        m, n = len(matrix), len(matrix[0])
        i, j = m-1, 0
        while i >= 0 and j < n:
            if target > matrix[i][j]: j += 1
            elif target < matrix[i][j]: i -= 1
            else: return True
        return False
```

#### [[动态规划]-279*. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201229143126100.png" alt="image-20201229143126100" style="zoom:50%;" />

> **A:** 动态规划，dp[i]找之前所有dp[j]的最小个数，记得保存下平方和的数组，不用每次都计算了；更优化的方法是完全背包问题，每个数x的价值为1，重量为x**2，找到恰好把背包装满的价值最小的方法
```python
class Solution:
    def numSquares(self, n: int) -> int:
        if n <= 2: return n
        square_nums = [i**2 for i in range(0, int(math.sqrt(n))+2)]
        dp = [float('inf') for i in range(n+1)]
        dp[0],dp[1] = 0,1
        for i in range(2,n+1):
            k = 1
            while square_nums[k] <= i:
                dp[i] = min(dp[i],dp[i-square_nums[k]]+1)
                k += 1
        return dp[-1]
#完全背包
class Solution:
    def numSquares(self, n: int) -> int:
        m = int(n**0.5)
        dp = list(range(n+1))
        for i in range(1, m):
            cur = (i + 1) ** 2
            for j in range(cur, n+1):
                dp[j] = min(dp[j], dp[j-cur] + 1)
        return dp[-1]
```

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201229142856221.png" alt="image-20201229142856221" style="zoom:50%;" />

> **A:** 两种思路，一种是遍历然后遇到的第j个非零数就和j位置上的元素交换；第二种是双指针，l找0，r找l后面的非零，然后交换
```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        l = r = 0
        while l < n-1:
            while l < n-1 and nums[l] != 0: l += 1
            r = max(r,l)
            while r < n-1 and nums[r] == 0: r += 1
            nums[l],nums[r] = nums[r],nums[l]
            l += 1

    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        j = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[j] , nums[i]= nums[i] , nums[j]
                j += 1
```

#### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201229140541160.png" alt="image-20201229140541160" style="zoom:50%;" />

> **A:** 类似141，142环形链表，名字叫Floyd 判圈算法，当链表中存在环，快慢指针相遇的地方重新令n=0，n和s再次相遇就是环入口
```python
#二分查找，原则是1-n中重复元素之前的元素count(小于等于i)<=i，之后的大于
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        #二分查找
        if not nums: return
        l,r = 1,len(nums)-1
        while l <= r:
            mid = l + (r-l)//2
            cnt = 0
            for num in nums:
                if num <= mid:
                    cnt += 1
            if cnt <= mid:
                l = mid+1
            else:
                r = mid-1
        return l
#双指针，当数组中存在重复数字，那么这个数字就自动成为环的入口
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        #双指针
        s,f = 0,0
        while True:
            s = nums[s]
            f = nums[nums[f]]
            if f == s: break #f和s相等时break
        new = 0
        while s != new:
            s = nums[s]
            new = nums[new]
        return s
```

#### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213143410812.png" alt="image-20201213143410812" style="zoom:50%;" />

> **A:** 层序遍历编码，之后再层序遍历解码
```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        #层序遍历
        if not root: return ''
        queue = [root]
        output = []
        while queue:
            node = queue.pop(0)
            if not node:
                output.append('None')
            else:
                output.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
        return ','.join(output)
        

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data: return None
        data = data.split(',')
        root = TreeNode(val=int(data[0]))
        data.pop(0) #这里也可以用index记录，似乎比pop快
        queue = [root]
        while queue:
            node = queue.pop(0)
            leftval = data.pop(0)
            if leftval != 'None':
                node.left = TreeNode(val = int(leftval))
                queue.append(node.left)
            rightval = data.pop(0)
            if rightval != 'None':
                node.right = TreeNode(val = int(rightval))
                queue.append(node.right)
        return root   
```

#### [[动态规划]-300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213171048192.png" alt="image-20201213171048192" style="zoom:50%;" />

> **A:** [答案分析](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/yi-bu-yi-bu-tui-dao-chu-guan-fang-zui-you-jie-fa-x/)，将问题转化为维护一个数组，然后可以利用二分法（也可以不用二分法暴力求解都行），但是要理解如何转化的；同样的问题还有[646. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)，也可以利用维护一个最佳数组解出来 p.s.:用DP也可以做，但是复杂度是ON2
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        #维护一个虚拟递增数组，新进来的找位置即可
        n = len(nums)
        tmp = [nums[0]]
        for i in range(1,n):
            index = self.bi_search(tmp,nums[i])
            if index >= len(tmp): tmp.append(nums[i])
            else: tmp[index] = nums[i]
        return len(tmp)
	# 通用二分查找
    def bi_search(self,tmp,target):
        l,r = 0,len(tmp)-1
        while l <= r:
            mid = l + (r-l) // 2
            if tmp[mid] < target:
                l = mid+1
            elif tmp[mid] > target:
                r = mid-1
            else: return mid
        return l

    
#DP硬做
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1 for i in range(n)] #dp[i]表示前i+1的最长子序列
        for i in range(1,n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i],dp[j]+1)
        return max(dp)
```

#### [[完全背包]-322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215143513776.png" alt="image-20201215143513776" style="zoom:50%;" />

> **A:** 第一种方法是最朴素的想法（这种一定要掌握，记得初始化要对，第一行全是0，第一列全是inf想象成0个硬币去拟合k需要无穷个），第二个是完全背包问题的解答（即第一种方法中`f[i][j]`只和上一层一个状态 (`f[i-1]f[j]`) 和这一层的一个状态 `(f[i][j-c]+1)` 有关。可以将状态优化为**一维数组**），见[这里](https://leetcode-cn.com/problems/coin-change/solution/yong-bei-bao-wen-ti-si-xiang-lai-li-jie-ying-bi-zh/)，思想不同于01背包，即第k轮更新后面的时候需要前面已经更新好了，故正序
```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if not coins: return -1
        n = len(coins)
        dp = [[float('inf') for i in range(amount+1)] for j in range(n+1)]
        #dp[0][0]代表没有硬币组成0需要0个硬币，dp[0]代表没有硬币组成k需要无穷个，dp[i][0]代表i个硬币组成0需要0
        for i in range(n+1): dp[i][0] = 0
        for i in range(1,n+1):
            for j in range(1,amount+1):
                if j < coins[i-1]: dp[i][j] = dp[i-1][j]
                else: dp[i][j] = min(dp[i-1][j],dp[i][j-coins[i-1]]+1)
        return dp[-1][-1] if dp[-1][-1] < float('inf') else -1
    
class Solution: #第一种方法的1D优化版
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf') for i in range(amount+1)]
        dp[0] = 0
        for coin in coins:
            for j in range(coin,amount+1):
                dp[j] = min(dp[j],dp[j-coin]+1)
        return dp[-1] if dp[-1] < float('inf') else -1
```

#### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209205439079.png" alt="image-20201209205439079" style="zoom:50%;" />

> **A:** 类似124，543和687，迭代过程中更新max但返回值不同；可以不用self.p，因为根肯定是最大的值；动态规划的方法以后可以学
```python
class Solution:
    def rob(self, root: TreeNode) -> int:
        # 分为偷根和不偷根
        def dfs(root):
            if not root: return 0,0
            tl,nl = dfs(root.left)
            tr,nr = dfs(root.right)
            #当前节点偷
            t = root.val + nl + nr
            #当前节点不偷
            nt = max(tl,nl)+max(tr,nr)
            return t,nt
        return max(dfs(root))
```

#### [[位运算]-338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

> **Q:**

> **A:** 可以采取从0-num的191的挨个计算，我是找规律做的；还可以用位运算的思想
```python
class Solution:
    def countBits(self, num: int) -> List[int]:
        if num == 0: return [0]
        import math
        k = int(math.log2(num))+1
        output = [0,1]
        for i in range(k-1):
            output += [x+1 for x in output] #找规律从0,1开始，后面的是前面的+1
        return output[:num+1]
#位运算
class Solution:
    def countBits(self, num: int) -> List[int]:
        #动态规划的思想，对于x来说，找到y是x最高位的1其余都是0，那么y是小于x的最大的2的幂，DP[x]=DP[x-y]+1
        #而如何找到y呢？利用y&y-1==0的特性即可
        dp = [0 for _ in range(num+1)]
        p2 = 0
        for i in range(1,num+1):
            if i & (i-1) == 0:
                p2 = i
            dp[i] = dp[i-p2]+1
        return dp
```

#### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

动态规划

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        #DP[i]表示i+1的乘积最大化
        if n <= 3: return n-1
        dp = [1 for _ in range(n)]
        dp[1] = 2
        dp[2] = 3
        for i in range(3,n):
            for j in range(i):
                dp[i] = max(dp[i],dp[j]*(i-j))
        return dp[-1]
#优化到O(N)
class Solution:
    def integerBreak(self, n: int) -> int:
        if n < 4:
            return n - 1
        
        dp = [0] * (n + 1)
        dp[2] = 1
        for i in range(3, n + 1):
            dp[i] = max(2 * (i - 2), 2 * dp[i - 2], 3 * (i - 3), 3 * dp[i - 3])
        
        return dp[n]
```

#### [378. 有序矩阵中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)

二分查找，这个题目会难一些，见[题解](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/you-xu-ju-zhen-zhong-di-kxiao-de-yuan-su-by-leetco/)以及下面JOxygen的评论

```python
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        def check(matrix,target,k):
            m,n = len(matrix),len(matrix[0])
            i,j = m-1,0
            count = 0
            while i >= 0 and j < n:
                if matrix[i][j] > target:
                    i -= 1
                else:
                    count += i+1
                    j += 1
            return count >= k

        l,r = matrix[0][0],matrix[-1][-1]
        while l <= r:
            mid = l+(r-l)//2
            if check(matrix,mid,k):
                r = mid-1
            else:
                l = mid+1
        return l
```



#### [[堆栈]-394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210101165136330.png" alt="image-20210101165136330" style="zoom:50%;" />

> **A:** 堆栈思想，分情况判断
```python
#https://blog.csdn.net/lssrain/article/details/88825776 判断字符串为字母or数字
class Solution:
    def decodeString(self, s: str) -> str:
        n = len(s)
        count = '' #防止100这样的字符串数字出现
        nums = [] #存放需要翻倍的字符串的倍数
        words = [] #存放需要翻倍的字符串
        output = ''
        for i in range(n):
            if s[i].isdigit(): #数字+给count
                count += s[i]
            elif s[i] == '[': #左括号说明数字到头了，将count转化为int，同时words加入空字符串
                nums.append(int(count))
                count = ''
                words.append('')
            elif s[i].isalpha(): #如果有倍数，需要翻倍放入words；否则直接放入output
                if not nums:
                    output += s[i]
                else:
                    words[-1] += s[i]
            elif s[i] == ']': #右括号代表数字+字符串结束，直接pop并相乘，之后和alpha字母的判断一致
                word = words.pop() * nums.pop()
                if not nums:
                    output += word
                else:
                    words[-1] += word
        return output
```
#### [400. 第 N 位数字](https://leetcode-cn.com/problems/nth-digit/)

先确定位数，再确定真实数字，最后确定位于数字的第几位

```python
class Solution:
    def findNthDigit(self, n: int) -> int:
        if n <= 9: return n
        base = 9
        digits = 1
        while n > base * digits: #确定位数
            n -= base * digits
            base *= 10
            digits += 1
        #确定数字
        num = 10**(digits-1) + n // digits
        if n % digits == 0: #特殊情况，如果除的尽要-1
            num -= 1
        #确定数字位置
        index = (num-10**(digits-1)+1) * digits - n
        return int(str(num)[digits-1-index])
```



#### [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210101174646283.png" alt="image-20210101174646283" style="zoom:50%;" />

> **A:** 两种方法：1.递归，找到0的最小身高k，必在第一个位置，之后所有比k矮的-1继续递归即可，记得1加回来；2. 按身高逆序，前人数升序，然后直接一个fo循环即可
```python
class Solution: #递归
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        n = len(people)
        if n < 2: return people
        mint,pop = float('inf'),0
        for i in range(n):
            if people[i][1] == 0 and mint > people[i][0]:
                mint = people[i][0]
                k = i
        people.pop(k)
        for j in range(n-1):
            if people[j][0] <= mint: people[j][1] -= 1
        new = self.reconstructQueue(people)
        for j in range(n-1):
            if new[j][0] <= mint: new[j][1] += 1        
        return [[mint,0]]+new

class Solution: #排序
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        n = len(people)
        people = sorted(people,key = lambda x:(-x[0],x[1]))
        new = []
        for i in range(n):
            k = people[i][1]
            if k != i:
                new.insert(k,people[i])
            else: new.append(people[i])
        return new
```

#### [[背包问题]-416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

子串和为k的问题，01背包

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        #同样是0-1背包问题，子序列和为k
        s = sum(nums)
        if s % 2 == 1: return False
        target = s // 2
        dp = [False] * (target+1)
        dp[0] = True
        for num in nums:
            for j in range(target,num-1,-1):
                dp[j] |= dp[j-num]
        return dp[-1]
```



#### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209174432896.png" alt="image-20201209174432896" style="zoom:50%;" />

> **A:** 和112路经总和原理类似，可以在那个的基础上递归做，也可以采用层序遍历的方法
```python
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> int:
        #BFS层序遍历带东西，前序遍历也可以
        if not root: return 0
        queue,res = [(root,[root.val])],0
        while queue:
            node,arr = queue.pop(0)
            res += arr.count(sum)
            arr.append(0)
            if node.left:
                temp = [x+node.left.val for x in arr]
                queue.append((node.left,temp))
            if node.right:
                temp = [x+node.right.val for x in arr]
                queue.append((node.right,temp))
        return res
#DFS递归做，记录累计和即可，每加入一个新元素就更新所有的和
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        def dfs(root,sumlist):
            count = 0
            if not root: return count
            sumlist = [num+root.val for num in sumlist]
            sumlist.append(root.val)
            return sumlist.count(targetSum) + dfs(root.left,sumlist) + dfs(root.right,sumlist)
        return dfs(root,[])
#自己写的
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        def inner(output,root,sums):
            if not root: return output
            sums.append(0)
            for i in range(len(sums)):
                sums[i] += root.val
                if sums[i] == targetSum:
                    output += 1
            output = inner(output,root.left,sums[:])
            output = inner(output,root.right,sums[:])
            return output
        return inner(0,root,[])
```

#### [[滑动窗口]-438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210101180356064.png" alt="image-20210101180356064" style="zoom:50%;" />

> **A:** 类似76最小覆盖子串，简化版，一起复习
```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        #类似76最小覆盖子串，只不过一些条件需要重新判断
        hashmap = {}
        for i in p:
            hashmap[i] = hashmap.get(i,0) + 1
        dic = hashmap.copy()
        n,m = len(s),len(p)
        count = m
        output = []
        l = 0
        for r in range(n):
            if s[r] in dic:
                while dic[s[r]] == 0: #如果s[r]已经填满了，那么不能再填入s[r]了，需要移动l让s[r]重新>0，比如abcbda和abcd
                    dic[s[l]] += 1
                    l += 1
                    count += 1
                dic[s[r]] -= 1
                count -= 1
                if count == 0:
                    output.append(l)
                    dic[s[l]] += 1
                    l += 1
                    count += 1
            else:
                l = r+1
                dic = hashmap.copy()
                count = m
        return output
                    
```

#### [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201216141031380.png" alt="image-20201216141031380" style="zoom:50%;" />

> **A:** 脑筋急转弯，第一次遍历把|nums[i]|-1位置的数变成负数，第二次遍历只需要找不是负的index就行了
```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums)
        output = []
        for i in range(n):
            index = abs(nums[i])-1
            if nums[index] > 0: nums[index] *= -1
        for j in range(n):
            if nums[j] > 0: output.append(j+1)
        return output
```

#### [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210101182059476.png" alt="image-20210101182059476" style="zoom:50%;" />

> **A:** 通过异或运算先找到所有不同，然后利用191布赖恩·克尼根算法计算位数
```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        nt = x^y #找到不同
        output = 0 #191布赖恩·克尼根算法计算位数
        while nt != 0:
            nt &= nt-1
            output += 1
        return output
#自己的想法，不断除以2，奇数就说明有1了，偶数则继续
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        r = x^y
        output = 0
        while r > 0:
            tmp = r//2
            output += r-2*tmp
            r = tmp
        return output
```

#### [470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

概率问题，调用两次rand7可以生成1-49的随机数，41-49不要，1-40等概率，后续生成10即可

```python
# The rand7() API is already defined for you.
# def rand7():
# @return a random integer in the range 1 to 7

class Solution:
    def rand10(self):
        """
        :rtype: int
        """
        while True:
            ten = rand7()
            one = rand7()
            num = one + (ten-1)*7
            if num <= 40: break
        return (num-1)//4+1
```



#### [[背包问题]-494. 目标和](https://leetcode-cn.com/problems/target-sum/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201215141443346.png" alt="image-20201215141443346" style="zoom:50%;" />

> **A:** 思路同416背包问题，将问题转化为从数列中找到和为num的子列，这个题是求数量；P.S.:注意判断S>数组和的情况，不然超时
```python
class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -> int:
        #同样转化为目标和
        if not nums: return 0
        s,n = sum(nums),len(nums)
        if (s+S)%2 == 1 or S > s: return 0
        target = (s+S)//2
        dp = [0 for i in range(target+1)]
        dp[0] = 1
        #01背包问题模板
        for i in range(n):
            for j in range(target,nums[i]-1,-1):
                dp[j] += dp[j-nums[i]]
        return dp[-1]
#传统2D背包问题
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        # #转化为找子串和为k
        s,n = sum(nums),len(nums)
        if (s+target)%2==1: return 0
        target = (s+target) // 2
        dp = [[0]*(target+1) for _ in range(n+1)]
        #dp[i][j]表示nums[:i]能构成j的子串个数
        for i in range(n+1): dp[i][0] = 1
        for p in range(1,n+1):
            for q in range(target+1):
                if q >= nums[p-1]: #2D背包问题不能省略nums[p-1]之前的元素
                    dp[p][q] = dp[p-1][q] + dp[p-1][q-nums[p-1]]
                else:
                    dp[p][q] = dp[p-1][q]
        return dp[-1][-1]
```

#### [528. 按权重随机选择](https://leetcode-cn.com/problems/random-pick-with-weight/)

前缀和+二分查找，例如数字是[1,3]代表0.25是0，0.75是1，前缀和为[1,4]，生成1-4即1234中的任意整数，找在[1,4]中的位置，1有1种，2-4有三种即可

```python
class Solution:

    def __init__(self, w: List[int]):
        #前缀和
        self.cursum = 0
        self.prefix = []
        for i in range(len(w)):
            self.cursum += w[i]
            self.prefix.append(self.cursum)
    def pickIndex(self) -> int:
        #二分查找找到第一个>=的元素
        def bi_search(seq,target):
            l,r = 0,len(seq)-1
            while l <= r:
                mid = l+(r-l)//2
                if seq[mid] == target:
                    return mid
                elif seq[mid] > target:
                    r = mid-1
                else:
                    l = mid+1
            return l
        num = random.randint(1,self.cursum)
        return bi_search(self.prefix,num)
```



#### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201213155534005.png" alt="image-20201213155534005" style="zoom:50%;" />

> **A:** 二叉搜索树的中序遍历有序，逆中序遍历为倒序（右-根-左），不断累加bigger和node.val相加即可
```python
class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        #利用中序遍历有序，两次遍历似乎可以，或者一次进行逆序中序遍历
        stack = []
        cumsum = 0
        node = root
        while stack or node:
            while node:
                stack.append(node)
                node = node.right
            node = stack.pop()
            node.val += cumsum
            cumsum = node.val #更新cumsum累计值
            node = node.left
        return root
```

#### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

> **Q:**

![image-20201209143206148](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209143206148.png)

> **A:** 递归求左右子树的高度并更新output；树的直径就等于某个根节点的左右子树的高度和。类似124，543和687，迭代过程中更新max但返回值不同

```python
class Solution:
    def __init__(self,):
        self.output = 0
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        #对于每个根节点来说，都是左个数+右个数+1-1
        def inner(root):
            if not root: return 0
            left = inner(root.left)
            right = inner(root.right)
            self.output = max(self.output,left+right)
            return max(left,right)+1
        inner(root)
        return self.output
```

#### [[前缀和]-560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210102154340607.png" alt="image-20210102154340607" style="zoom:50%;" />

> **A:** 前缀和。j-i的连续子序列和可以表示为[0,i]-[0,j-1]，故我们只需要收集0-n-1的所有子序列和，之后做差即可，用hashmap可以优化，key是和的值，value是取该和的子序列个数

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        #第一反应想到的是DP，DP[i][j]表示以nums[i]结尾的能构成的和为j的连续数组
        #但数组中有负的，故不行
        #回溯？也不行
        #前缀和，之后找两数之差==k的，类似1两数之和
        n = len(nums)
        prefix = []
        cursum = 0
        hashmap = {k:1} #注意这个k:1，此时前面的前缀和为0，是天然自带的
        output = 0
        for i in range(n):
            cursum += nums[i]
            prefix.append(cursum)
            if prefix[i] in hashmap:
                output += hashmap[prefix[i]]
            hashmap[prefix[i]+k] = hashmap.get(prefix[i]+k,0)+1
        return output
```

#### [572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209180411271.png" alt="image-20201209180411271" style="zoom:50%;" />

> **A:** 一棵子树上的点在 DFS 序列（即先序遍历）中是连续的，但是要注意空子树用*代替，每条子树开头+#以防[12]和[2]这样的树

```python
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        ss = self.preorder(s)
        st = self.preorder(t)
        print(st,ss)
        return st in ss
        
    def preorder(self,root):
        stack,output = [root],""
        while stack:
            node = stack.pop()
            if node: 
                output += '#'+str(node.val)
                stack.append(node.right)
                stack.append(node.left)
            else: output += '*'

        return output
#递归的方法，内部递归函数鉴定两棵树是否一致，灵感来源于剑指26
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:

        if not s: return False

        def recur(p1,p2):
            if not p1 and not p2: return True
            if not p1 or not p2: return False
            if p1.val != p2.val: return False
            else: return recur(p1.left,p2.left) and recur(p1.right,p2.right)
        
        return recur(s,t) or self.isSubtree(s.left,t) or self.isSubtree(s.right,t)
```

#### [581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210102163540289.png" alt="image-20210102163540289" style="zoom:50%;" />

> **A:** 1. 排序后比较第一个和最后一个位置不对的left和right 2. 找到**最短子序列中**最小值和最大值需要安放的地方即可
```python
class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        #分为ABC三段，A段的每个元素要小于A[i]之后的最小值
        #同理，C段的每个元素要大于C[i]之前的最大值
        #可以用找最大最小list的方法确定A和C的边界
        #也可以用一次遍历的方法确定B的边界，即逆向思维，找不满足上述AC的情况即为B的边界
        #分为ABC三段，找B段的开始和结尾
        n = len(nums)
        maxn, right = float("-inf"), -1
        minn, left = float("inf"), -1

        for i in range(n):
            if maxn > nums[i]:
                right = i
            else:
                maxn = nums[i]
            
            if minn < nums[n - i - 1]:
                left = n - i - 1
            else:
                minn = nums[n - i - 1]
        
        return 0 if right == -1 else right - left + 1

        #复杂度为O(N)的方法
        #分三段，ABC，A中的所有元素i小于i后续元素的最小值，C中则大于
        #故问题转化为找i右边的最小值，和i左边的最大值，同42接雨水
        n = len(nums)
        ldp = [float('-inf') for _ in range(n)]
        rdp = [float('inf') for _ in range(n)]
        for i in range(1,n):
            ldp[i] = max(ldp[i-1],nums[i-1])
        for j in range(n-2,-1,-1):
            rdp[j] = min(rdp[j+1],nums[j+1])
        l,r = 0,n-1
        while l <= n-1 and nums[l] <= rdp[l]:
            l += 1
        while r >= 0 and nums[r] >= ldp[r]:
            r -= 1
        #print(l,r,ldp,rdp)
        return r-l+1 if r >= l else 0
```

#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209154239131.png" alt="image-20201209154239131" style="zoom:50%;" />

> **A:** 递归的方法都可以用层序遍历做
```python
class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
        if not t1: return t2
        if not t2: return t1
        t1.val = t1.val + t2.val
        t1.left = self.mergeTrees(t1.left,t2.left)
        t1.right = self.mergeTrees(t1.right,t2.right)
        return t1
```

#### [[动态规划]-647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210102165555536.png" alt="image-20210102165555536" style="zoom:50%;" />

> **A:** 思路同5最长回文子串，记录个数即可，动态规划
```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        #同最长回文子串，DP[i][j]表示长度为i+1的从j开始的是否为回文子串
        n = len(s)
        dp = [[False]*n for _ in range(n+1)]
        dp[0] = dp[1] = [True]*n
        r = n
        for i in range(2,n+1):
            for j in range(n-i+1):
                if s[j] == s[j+i-1] and dp[i-2][j+1]:
                    dp[i][j] = True
                    r += 1
        return r
```

#### [670. 最大交换](https://leetcode-cn.com/problems/maximum-swap/)

思路是交换最高位和后续的比他大的，这个最高位也会更新

```python
class Solution:
    def maximumSwap(self, num: int) -> int:
        #思路是交换最高位和后续的比他大的，这个最高位也会更新
        num = list(map(int,str(num)))
        n = len(num)
        rightmax = [(0,0) for i in range(n-1)]
        tmp = num[n-1]
        index = n-1
        for i in range(n-2,-1,-1):
            rightmax[i] = (tmp,index)
            if num[i] > tmp: #等于的时候不要更新index，因为小的数越后面越好
                tmp = num[i]
                index = i
        for j in range(n-1):
            if num[j] < rightmax[j][0]:
                index = rightmax[j][1]
                num[j],num[index] = num[index],num[j]
                return int(''.join(list(map(str,num))))
        return int(''.join(list(map(str,num))))
```

#### [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

类似300，但是难度更大；同样可以用DP或者二分查找维护虚拟递增子序列两种方法

```python
class Solution:
    def findNumberOfLIS(self, nums):
        #维护一个单调递增的虚拟子序列+二分查找
        #更新结果上有变化
        n = len(nums)
        hashmap = {} #通过一个hashmap存储每个子序列长度的结尾以及对应序列个数，如{0:{1:1,2:2}}表示长度为1的子序列，以1结尾的有1个，2的有2个
        output = 0
        seq = []
        def bi_search(seq,target):
            n = len(seq)
            l,r = 0,n-1
            while l <= r:
                mid = l+(r-l)//2
                if seq[mid] == target:
                    return mid
                elif seq[mid] < target:
                    l = mid+1
                else:
                    r = mid-1
            return l
        for i in range(n):
            index = bi_search(seq,nums[i])
            if index == len(seq):
                seq.append(nums[i])
            else:
                seq[index] = nums[i]
            count = 0
            if index-1 in hashmap:
                for s in hashmap[index-1]:
                    if s < nums[i]:
                        count += hashmap[index-1][s]
            else: count = 1
            newhash = hashmap.get(index,{})
            newhash[nums[i]] = newhash.get(nums[i],0)+count
            hashmap[index] = newhash
        return sum(hashmap[len(seq)-1].values())
#DP方法
class Solution:
    def findNumberOfLIS(self, nums):
        #DP动态规划的方法
        #DP[i]表示以nums[i]为结尾的子序列的个数和长度
        n = len(nums)
        dp = [[1,1] for _ in range(n)]
        dp[0] = [1,1]
        maxlen = 1
        for i in range(n):
            for j in range(i):
                if nums[i] > nums[j]:
                    count,lens = dp[j]
                    if lens+1 == dp[i][1]:
                        dp[i][0] += count
                    elif lens+1 > dp[i][1]:
                        dp[i] = [count,lens+1]
                        maxlen = max(maxlen,dp[i][1])
        return sum([i[0] if i[1] == maxlen else 0 for i in dp])
```

#### [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

> **Q:**

![image-20201209203844677](C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201209203844677.png)

> **A:** 类似124和543两道题目，递归的过程中更新max但是递归返回值不同于max，思考见[github](https://github.com/zjuzhfbloodz/LeetCode/blob/master/leetcode-algorithms/687.%20Longest%20Univalue%20Path/0687.md)很清楚
```python
class Solution:
    def longestUnivaluePath(self, root: TreeNode) -> int:
        self.p = 0
        
        def inner(root):
            if not root: return 0
            if not root.left and not root.right: return 1
            ml,mr = 0,0 #ml和mr是为了后面判断更方便，即ml>0说明左子树和根相等，否则说明不等
            left = inner(root.left)
            right = inner(root.right)
            if root.left and root.left.val == root.val:
                ml += left
            if root.right and root.right.val == root.val:
                mr += right
            self.p = max(self.p,ml+mr)
            if ml > 0 and mr > 0: return max(ml,mr)+1
            else: return ml+mr+1

        inner(root)
        return self.p
```

#### [[DFS]-695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

网格DFS经典题目，思路见[这里](https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)，200-463-695-827

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        m,n = len(grid),len(grid[0])
        def dfs(area,i,j):
            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != 1: #没办法走，边界and水and走过的地方
                return area
            grid[i][j] = 2 #走过的地方标记为2
            area += 1
            area = dfs(area,i-1,j) #继续走
            area = dfs(area,i,j-1)
            area = dfs(area,i+1,j)
            area = dfs(area,i,j+1)
            return area
        output = 0
        for i in range(m):
            for j in range(n):
                output = max(output,dfs(0,i,j))
        return output
```



#### [[单调栈]-739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

经典单调栈题目

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        #维护一个单调递减的栈
        n = len(temperatures)
        stack = []
        output = [0 for _ in range(n)]
        for i in range(n):
            while stack and temperatures[stack[-1]] < temperatures[i]:
                index = stack.pop()
                output[index] = i-index
            stack.append(i)
        return output
```



#### [[哈希]-771. 宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20210102170218865.png" alt="image-20210102170218865" style="zoom:50%;" />

> **A:** Hashmap两次遍历即可
```python
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        dic,output = {},0
        for s in stones:
            if dic.get(s): dic[s] += 1
            else: dic[s] = 1
        for j in jewels:
            output += dic.get(j,0)
        return output
```

#### [[动态规划]-1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

> **Q:**

<img src="C:\Users\Bloodz\AppData\Roaming\Typora\typora-user-images\image-20201222153914181.png" alt="image-20201222153914181" style="zoom:50%;" />

> **A:** 动态规划，如果text1[i] == text2[j]，则DP要更新，否则选最大的；[583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)，思路一致，求得公共子串后即得
```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        #DP[i][j]表示text1的前i个字符和text2的前j个字符的最长子序列长度
        m,n = len(text1),len(text2)
        dp = [[0]*(n+1) for i in range(m+1)]
        for i in range(1,m+1):
            for j in range(1,n+1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])
        return dp[-1][-1]
```